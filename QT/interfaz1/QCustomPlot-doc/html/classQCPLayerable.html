<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QCPLayerable Class Reference</title>
<link href="qt.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class=header>
<a class=headerLink  href="index.html">Main Page</a> &middot;
<a class=headerLink  href="classoverview.html">Class Overview</a> &middot;
<a class=headerLink  href="hierarchy.html">Hierarchy</a> &middot;
<a class=headerLink  href="annotated.html">All Classes</a>
</div>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Functions</a> &#124;
<a href="#pro-methods">Protected Functions</a>  </div>
  <div class="headertitle">
<div class="title">QCPLayerable Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="QCPLayerable" -->
<p>Base class for all objects that can be placed on layers.  
 <a href="classQCPLayerable.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for QCPLayerable:</div>
<div class="dyncontent">
<div class="center"><img src="classQCPLayerable__inherit__graph.png" border="0" usemap="#QCPLayerable_inherit__map" alt="Inheritance graph"/></div>
<map name="QCPLayerable_inherit__map" id="QCPLayerable_inherit__map">
<area shape="rect" id="node3" href="classQCPAbstractItem.html" title="The abstract base class for all items in a plot." alt="" coords="167,221,284,246"/><area shape="rect" id="node23" href="classQCPAbstractPlottable.html" title="The abstract base class for all data representing objects in a plot." alt="" coords="155,485,296,510"/><area shape="rect" id="node33" href="classQCPAxis.html" title="Manages a single axis inside a QCustomPlot." alt="" coords="192,533,259,558"/><area shape="rect" id="node35" href="classQCPGrid.html" title="Responsible for drawing the grid of a QCPAxis." alt="" coords="191,581,260,606"/><area shape="rect" id="node37" href="classQCPLegend.html" title="Manages a legend inside a QCustomPlot." alt="" coords="183,629,268,654"/><area shape="rect" id="node5" href="classQCPItemBracket.html" title="A bracket for referencing/highlighting certain parts in the plot." alt="" coords="356,5,471,30"/><area shape="rect" id="node7" href="classQCPItemCurve.html" title="A curved line from one point to another." alt="" coords="361,53,465,78"/><area shape="rect" id="node9" href="classQCPItemEllipse.html" title="An ellipse." alt="" coords="360,101,467,126"/><area shape="rect" id="node11" href="classQCPItemLine.html" title="A line from one point to another." alt="" coords="367,149,460,174"/><area shape="rect" id="node13" href="classQCPItemPixmap.html" title="An arbitrary pixmap." alt="" coords="357,197,469,222"/><area shape="rect" id="node15" href="classQCPItemRect.html" title="A rectangle." alt="" coords="367,245,460,270"/><area shape="rect" id="node17" href="classQCPItemStraightLine.html" title="A straight line that spans infinitely in both directions." alt="" coords="344,293,483,318"/><area shape="rect" id="node19" href="classQCPItemText.html" title="A text label." alt="" coords="367,341,460,366"/><area shape="rect" id="node21" href="classQCPItemTracer.html" title="Item that sticks to QCPGraph data points." alt="" coords="360,389,467,414"/><area shape="rect" id="node25" href="classQCPBars.html" title="A plottable representing a bar chart in a plot." alt="" coords="377,437,449,462"/><area shape="rect" id="node27" href="classQCPCurve.html" title="A plottable representing a parametric curve in a plot." alt="" coords="375,485,452,510"/><area shape="rect" id="node29" href="classQCPGraph.html" title="A plottable representing a graph in a plot." alt="" coords="373,533,453,558"/><area shape="rect" id="node31" href="classQCPStatisticalBox.html" title="A plottable representing a single statistical box in a plot." alt="" coords="352,581,475,606"/></map>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a13db44e350bb2c681d2e31e2208e23f9">QCPLayerable</a> (<a class="el" href="classQCustomPlot.html">QCustomPlot</a> *parentPlot)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a3cc92e0fa63e4a929e61d34e275a7"></a><!-- doxytag: member="QCPLayerable::visible" ref="a10a3cc92e0fa63e4a929e61d34e275a7" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>visible</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7e0e94461566093d36ffc0f5312b109"></a><!-- doxytag: member="QCPLayerable::parentPlot" ref="ab7e0e94461566093d36ffc0f5312b109" args="() const " -->
<a class="el" href="classQCustomPlot.html">QCustomPlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parentPlot</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea67e8c19145e70d68c286a36f6b8300"></a><!-- doxytag: member="QCPLayerable::layer" ref="aea67e8c19145e70d68c286a36f6b8300" args="() const " -->
<a class="el" href="classQCPLayer.html">QCPLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>layer</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5cb4aa899ed9dc9384fd614560291e"></a><!-- doxytag: member="QCPLayerable::antialiased" ref="aef5cb4aa899ed9dc9384fd614560291e" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>antialiased</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a3bed99ddc396b48ce3ebfdc0418744f8">setVisible</a> (bool on)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#ab0d0da6d2de45a118886d2c8e16d5a54">setLayer</a> (<a class="el" href="classQCPLayer.html">QCPLayer</a> *layer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#ab25a0e7b897993b44447caee0f142083">setLayer</a> (const QString &amp;layerName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">setAntialiased</a> (bool enabled)</td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#af94484cfb7cbbddb7de522e9be71d9a4">moveToLayer</a> (<a class="el" href="classQCPLayer.html">QCPLayer</a> *layer, bool prepend)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a62bd552d1a45aa9accb24b310542279e">applyAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, bool localAntialiased, <a class="el" href="namespaceQCP.html#ae55dbe315d41fe80f29ba88100843a0c">QCP::AntialiasedElement</a> overrideElement) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#afdf83ddc6a265cbf4c89fe99d3d93473">applyDefaultAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const =0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a07a8f746640c3704b09910df297afcba">clipRect</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#aecf2f7087482d4b6a78cb2770e5ed12d">draw</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter)=0</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Base class for all objects that can be placed on layers. </p>
<p>This is the abstract base class most visible objects derive from, e.g. plottables, axes, grid etc.</p>
<p>Every layerable is on a layer (<a class="el" href="classQCPLayer.html" title="A layer that may contain objects, to control the rendering order.">QCPLayer</a>) which allows controlling the rendering order by stacking the layers accordingly.</p>
<p>For details about the layering mechanism, see the <a class="el" href="classQCPLayer.html" title="A layer that may contain objects, to control the rendering order.">QCPLayer</a> documentation. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a13db44e350bb2c681d2e31e2208e23f9"></a><!-- doxytag: member="QCPLayerable::QCPLayerable" ref="a13db44e350bb2c681d2e31e2208e23f9" args="(QCustomPlot *parentPlot)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPLayerable.html#a13db44e350bb2c681d2e31e2208e23f9">QCPLayerable::QCPLayerable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCustomPlot.html">QCustomPlot</a> *&#160;</td>
          <td class="paramname"><em>parentPlot</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Creates a new <a class="el" href="classQCPLayerable.html" title="Base class for all objects that can be placed on layers.">QCPLayerable</a> instance.</p>
<p>Since <a class="el" href="classQCPLayerable.html" title="Base class for all objects that can be placed on layers.">QCPLayerable</a> is an abstract base class, it can't be instantiated directly. Use one of the derived classes. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3bed99ddc396b48ce3ebfdc0418744f8"></a><!-- doxytag: member="QCPLayerable::setVisible" ref="a3bed99ddc396b48ce3ebfdc0418744f8" args="(bool on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPLayerable.html#a3bed99ddc396b48ce3ebfdc0418744f8">QCPLayerable::setVisible</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> surface, and user interaction with it (e.g. click/selection) is not possible. </p>

</div>
</div>
<a class="anchor" id="ab0d0da6d2de45a118886d2c8e16d5a54"></a><!-- doxytag: member="QCPLayerable::setLayer" ref="ab0d0da6d2de45a118886d2c8e16d5a54" args="(QCPLayer *layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQCPLayerable.html#ab0d0da6d2de45a118886d2c8e16d5a54">QCPLayerable::setLayer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPLayer.html">QCPLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <em>layer</em> of this layerable object. The object will be placed on top of the other objects already on <em>layer</em>.</p>
<p>Returns true on success, i.e. if <em>layer</em> is a valid layer. </p>

</div>
</div>
<a class="anchor" id="ab25a0e7b897993b44447caee0f142083"></a><!-- doxytag: member="QCPLayerable::setLayer" ref="ab25a0e7b897993b44447caee0f142083" args="(const QString &amp;layerName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQCPLayerable.html#ab0d0da6d2de45a118886d2c8e16d5a54">QCPLayerable::setLayer</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>layerName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Sets the layer of this layerable object by name</p>
<p>Returns true on success, i.e. if <em>layerName</em> is a valid layer name. </p>

</div>
</div>
<a class="anchor" id="a4fd43e89be4a553ead41652565ff0581"></a><!-- doxytag: member="QCPLayerable::setAntialiased" ref="a4fd43e89be4a553ead41652565ff0581" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">QCPLayerable::setAntialiased</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets whether this object will be drawn antialiased or not.</p>
<p>Note that antialiasing settings may be overridden by <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. </p>

</div>
</div>
<a class="anchor" id="af94484cfb7cbbddb7de522e9be71d9a4"></a><!-- doxytag: member="QCPLayerable::moveToLayer" ref="af94484cfb7cbbddb7de522e9be71d9a4" args="(QCPLayer *layer, bool prepend)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQCPLayerable.html#af94484cfb7cbbddb7de522e9be71d9a4">QCPLayerable::moveToLayer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPLayer.html">QCPLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prepend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves this layerable object to <em>layer</em>. If <em>prepend</em> is true, this object will be prepended to the new layer's list, i.e. it will be drawn below the objects already on the layer. If it is false, the object will be appended.</p>
<p>Returns true on success, i.e. if <em>layer</em> is a valid layer. </p>

</div>
</div>
<a class="anchor" id="a62bd552d1a45aa9accb24b310542279e"></a><!-- doxytag: member="QCPLayerable::applyAntialiasingHint" ref="a62bd552d1a45aa9accb24b310542279e" args="(QCPPainter *painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPLayerable.html#a62bd552d1a45aa9accb24b310542279e">QCPLayerable::applyAntialiasingHint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>localAntialiased</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceQCP.html#ae55dbe315d41fe80f29ba88100843a0c">QCP::AntialiasedElement</a>&#160;</td>
          <td class="paramname"><em>overrideElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the QPainter::Antialiasing render hint on the provided <em>painter</em>, depending on the <em>localAntialiased</em> value as well as the overrides <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. Which override enum this function takes into account is controlled via <em>overrideElement</em>. </p>

</div>
</div>
<a class="anchor" id="afdf83ddc6a265cbf4c89fe99d3d93473"></a><!-- doxytag: member="QCPLayerable::applyDefaultAntialiasingHint" ref="afdf83ddc6a265cbf4c89fe99d3d93473" args="(QCPPainter *painter) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPLayerable.html#afdf83ddc6a265cbf4c89fe99d3d93473">QCPLayerable::applyDefaultAntialiasingHint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td> const<code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function applies the default antialiasing setting to the specified <em>painter</em>, using the function <a class="el" href="classQCPLayerable.html#a62bd552d1a45aa9accb24b310542279e">applyAntialiasingHint</a>. This is the antialiasing state the painter is in, when <a class="el" href="classQCPLayerable.html#aecf2f7087482d4b6a78cb2770e5ed12d">draw</a> is called on the layerable. If the layerable has multiple entities whose antialiasing setting may be specified individually, this function should set the antialiasing state of the most prominent entity. In this case however, the <a class="el" href="classQCPLayerable.html#aecf2f7087482d4b6a78cb2770e5ed12d">draw</a> function usually calls the specialized versions of this function before drawing each entity, effectively overriding the setting of the default antialiasing hint.</p>
<p><b>First example:</b> <a class="el" href="classQCPGraph.html" title="A plottable representing a graph in a plot.">QCPGraph</a> has multiple entities that have an antialiasing setting: The graph line, fills, scatters and error bars. Those can be configured via <a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">QCPGraph::setAntialiased</a>, <a class="el" href="classQCPAbstractPlottable.html#a089d6b5577120239b55c39ed27c39536">QCPGraph::setAntialiasedFill</a>, <a class="el" href="classQCPAbstractPlottable.html#a2f03f067ede2ed4da6f7d0e4777a3f02">QCPGraph::setAntialiasedScatters</a> etc. Consequently, there isn't only the <a class="el" href="classQCPAbstractPlottable.html#a76e9d6cc7972dc1528f526d163766aca">QCPGraph::applyDefaultAntialiasingHint</a> function (which corresponds to the graph line's antialiasing), but specialized ones like <a class="el" href="classQCPAbstractPlottable.html#ac08a480155895e674dbfe5a5670e0ff3">QCPGraph::applyFillAntialiasingHint</a> and <a class="el" href="classQCPAbstractPlottable.html#a753272ee225a62827e90c3e1e78de4b1">QCPGraph::applyScattersAntialiasingHint</a>. So before drawing one of those entities, <a class="el" href="classQCPGraph.html#a659218cc62c2a7786213d9dd429c1c8d">QCPGraph::draw</a> calls the respective specialized applyAntialiasingHint function.</p>
<p><b>Second example:</b> <a class="el" href="classQCPItemLine.html" title="A line from one point to another.">QCPItemLine</a> consists only of a line so there is only one antialiasing setting which can be controlled with <a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">QCPItemLine::setAntialiased</a>. (This function is inherited by all layerables. The specialized functions, as seen on <a class="el" href="classQCPGraph.html" title="A plottable representing a graph in a plot.">QCPGraph</a>, must be added explicitly to the respective layerable subclass.) Consequently it only has the normal <a class="el" href="classQCPAbstractItem.html#a0839031abdd71067e2256a4d53c7a011">QCPItemLine::applyDefaultAntialiasingHint</a>. The <a class="el" href="classQCPItemLine.html#a1fc045dd33919f8006df0692aeb0e84a">QCPItemLine::draw</a> function doesn't need to care about setting any antialiasing states, because the default antialiasing hint is already set on the painter when the <a class="el" href="classQCPLayerable.html#aecf2f7087482d4b6a78cb2770e5ed12d">draw</a> function is called, and that's the state it wants to draw the line with. </p>

<p>Implemented in <a class="el" href="classQCPAxis.html#a13bde39eb1e0b7c14a02935689be8aba">QCPAxis</a>, <a class="el" href="classQCPGrid.html#a9916f5e38b4d6cae446537aeb47c7272">QCPGrid</a>, <a class="el" href="classQCPLegend.html#a26307f532c3458b379663b7d517a5f47">QCPLegend</a>, <a class="el" href="classQCPAbstractItem.html#a0839031abdd71067e2256a4d53c7a011">QCPAbstractItem</a>, and <a class="el" href="classQCPAbstractPlottable.html#a76e9d6cc7972dc1528f526d163766aca">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="a07a8f746640c3704b09910df297afcba"></a><!-- doxytag: member="QCPLayerable::clipRect" ref="a07a8f746640c3704b09910df297afcba" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QRect <a class="el" href="classQCPLayerable.html#a07a8f746640c3704b09910df297afcba">QCPLayerable::clipRect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the clipping rectangle of this layerable object. By default, this is the viewport of the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>. Specific subclasses may reimplement this function to provide different clipping rects.</p>
<p>The returned clipping rect is set on the painter before the draw function of the respective object is called. </p>

<p>Reimplemented in <a class="el" href="classQCPAbstractItem.html#a538e25ff8856534582f5b2b400a46405">QCPAbstractItem</a>, and <a class="el" href="classQCPAbstractPlottable.html#ac01960b0827913922f5364d559c124ed">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="aecf2f7087482d4b6a78cb2770e5ed12d"></a><!-- doxytag: member="QCPLayerable::draw" ref="aecf2f7087482d4b6a78cb2770e5ed12d" args="(QCPPainter *painter)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPLayerable.html#aecf2f7087482d4b6a78cb2770e5ed12d">QCPLayerable::draw</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function draws the layerable to the specified <em>painter</em>.</p>
<p>Before this function is called, the painter's antialiasing state is set via <a class="el" href="classQCPLayerable.html#afdf83ddc6a265cbf4c89fe99d3d93473">applyDefaultAntialiasingHint</a>, see the documentation there. Further, its clipping rectangle was set to <a class="el" href="classQCPLayerable.html#a07a8f746640c3704b09910df297afcba">clipRect</a>. </p>

<p>Implemented in <a class="el" href="classQCPAxis.html#a258b1e783eda5cd14ec5552c696a424e">QCPAxis</a>, <a class="el" href="classQCPGrid.html#ad009c23f96078616aa4f66a750974b23">QCPGrid</a>, <a class="el" href="classQCPLegend.html#a4462151bf875ca85fa3815457c683fdc">QCPLegend</a>, <a class="el" href="classQCPItemTracer.html#aaaf49b48382c730ec9be0e74c2538315">QCPItemTracer</a>, <a class="el" href="classQCPItemBracket.html#a8343cf0559c64886add7aa7f4b22f1a6">QCPItemBracket</a>, <a class="el" href="classQCPItemCurve.html#a56cb5b72cd02db2eda598274a39839a9">QCPItemCurve</a>, <a class="el" href="classQCPItemText.html#a8793adb271ab79b4cf391dc55e9987f1">QCPItemText</a>, <a class="el" href="classQCPItemPixmap.html#a879e8076c2db01a38b34cfa73ec95d2f">QCPItemPixmap</a>, <a class="el" href="classQCPItemRect.html#a18cd583638b876cdd50f1a155ec182aa">QCPItemRect</a>, <a class="el" href="classQCPItemEllipse.html#afe97ec827adb05f000fe007783faae3c">QCPItemEllipse</a>, <a class="el" href="classQCPItemLine.html#a1fc045dd33919f8006df0692aeb0e84a">QCPItemLine</a>, <a class="el" href="classQCPItemStraightLine.html#a2daa1e1253216c26565d56a2d5530170">QCPItemStraightLine</a>, <a class="el" href="classQCPAbstractItem.html#ad0dc056f650c3ca73414e6b4f01674ef">QCPAbstractItem</a>, <a class="el" href="classQCPStatisticalBox.html#a753b62761217dd6b92f8a29e286a1317">QCPStatisticalBox</a>, <a class="el" href="classQCPBars.html#a42b894e34dac799f90ff3700706b31df">QCPBars</a>, <a class="el" href="classQCPCurve.html#a2361302d2fc6ec669849bd3bca00c4b2">QCPCurve</a>, <a class="el" href="classQCPGraph.html#a659218cc62c2a7786213d9dd429c1c8d">QCPGraph</a>, and <a class="el" href="classQCPAbstractPlottable.html#aae10c24c7ed9d9364f0a5a4d9a5e5aec">QCPAbstractPlottable</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qcustomplot_8h_source.html">qcustomplot.h</a></li>
<li>qcustomplot.cpp</li>
</ul>
</div><!-- contents -->
<div class="footer" />Generated with <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.7.6.1</div>
</body>
</html>
