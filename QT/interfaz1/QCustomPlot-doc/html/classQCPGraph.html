<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>QCPGraph Class Reference</title>
<link href="qt.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div class=header>
<a class=headerLink  href="index.html">Main Page</a> &middot;
<a class=headerLink  href="classoverview.html">Class Overview</a> &middot;
<a class=headerLink  href="hierarchy.html">Hierarchy</a> &middot;
<a class=headerLink  href="annotated.html">All Classes</a>
</div>
<!-- Generated by Doxygen 1.7.6.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Functions</a> &#124;
<a href="#signals">Signals</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Functions</a>  </div>
  <div class="headertitle">
<div class="title">QCPGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="QCPGraph" --><!-- doxytag: inherits="QCPAbstractPlottable" -->
<p>A plottable representing a graph in a plot.  
 <a href="classQCPGraph.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for QCPGraph:</div>
<div class="dyncontent">
<div class="center"><img src="classQCPGraph__inherit__graph.png" border="0" usemap="#QCPGraph_inherit__map" alt="Inheritance graph"/></div>
<map name="QCPGraph_inherit__map" id="QCPGraph_inherit__map">
<area shape="rect" id="node2" href="classQCPAbstractPlottable.html" title="The abstract base class for all data representing objects in a plot." alt="" coords="5,81,147,106"/><area shape="rect" id="node4" href="classQCPLayerable.html" title="Base class for all objects that can be placed on layers." alt="" coords="25,6,127,31"/></map>
</div>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">LineStyle</a> </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a> </td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0393a38cf7183cbf46348eb6cf9a5a6c">QCPGraph</a> (<a class="el" href="classQCPAxis.html">QCPAxis</a> *keyAxis, <a class="el" href="classQCPAxis.html">QCPAxis</a> *valueAxis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f4c17d993df4759c7426db45b33fbc0"></a><!-- doxytag: member="QCPGraph::data" ref="a8f4c17d993df4759c7426db45b33fbc0" args="() const " -->
const <a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6db8d31abeac256a285fc68d6b9b9be"></a><!-- doxytag: member="QCPGraph::lineStyle" ref="ad6db8d31abeac256a285fc68d6b9b9be" args="() const " -->
<a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">LineStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lineStyle</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3997fdcb68f8543395d964e09562f861"></a><!-- doxytag: member="QCPGraph::scatterStyle" ref="a3997fdcb68f8543395d964e09562f861" args="() const " -->
<a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26f">QCP::ScatterStyle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scatterStyle</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3d8e1e8affba4d443925b2e3e0d633c4"></a><!-- doxytag: member="QCPGraph::scatterSize" ref="a3d8e1e8affba4d443925b2e3e0d633c4" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>scatterSize</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fb25d67dc6f85004d913ceb945beae3"></a><!-- doxytag: member="QCPGraph::scatterPixmap" ref="a1fb25d67dc6f85004d913ceb945beae3" args="() const " -->
const QPixmap&#160;</td><td class="memItemRight" valign="bottom"><b>scatterPixmap</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a250bcdf78abac87bc6d46ee6fd99a92d"></a><!-- doxytag: member="QCPGraph::errorType" ref="a250bcdf78abac87bc6d46ee6fd99a92d" args="() const " -->
<a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a>&#160;</td><td class="memItemRight" valign="bottom"><b>errorType</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83455e01093bb899f3b59d4a6fdcd57b"></a><!-- doxytag: member="QCPGraph::errorPen" ref="a83455e01093bb899f3b59d4a6fdcd57b" args="() const " -->
QPen&#160;</td><td class="memItemRight" valign="bottom"><b>errorPen</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae31efdcbc6ba3d73a7aeb83c774f958a"></a><!-- doxytag: member="QCPGraph::errorBarSize" ref="ae31efdcbc6ba3d73a7aeb83c774f958a" args="() const " -->
double&#160;</td><td class="memItemRight" valign="bottom"><b>errorBarSize</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04dbc050ff04561658ab1e7f3df37a01"></a><!-- doxytag: member="QCPGraph::errorBarSkipSymbol" ref="a04dbc050ff04561658ab1e7f3df37a01" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>errorBarSkipSymbol</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5369f23863e04a6164f8b66d49fd18f4"></a><!-- doxytag: member="QCPGraph::channelFillGraph" ref="a5369f23863e04a6164f8b66d49fd18f4" args="() const " -->
<a class="el" href="classQCPGraph.html">QCPGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>channelFillGraph</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a1df2fd710545c8ba3b2c99a39a27bf8b">setData</a> (<a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> *data, bool copy=false)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a4c55d8ac13bfa42c8c93747820891a76">setData</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abce9f07c0d722bc3e4fa7bd73c7e5dfa">setDataKeyError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ac15c749c5fedf740d5692c6fe67143b8">setDataKeyError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyErrorMinus, const QVector&lt; double &gt; &amp;keyErrorPlus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#acba6296eadcb36b93267628b8dae3de5">setDataValueError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;valueError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a3afbfd7222d739351c69387904776f93">setDataValueError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;valueErrorMinus, const QVector&lt; double &gt; &amp;valueErrorPlus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a873fe46bdb20be5710428e474ade8908">setDataBothError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyError, const QVector&lt; double &gt; &amp;valueError)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abb75736ecdbf6e6a7501e1da64fb18cf">setDataBothError</a> (const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyErrorMinus, const QVector&lt; double &gt; &amp;keyErrorPlus, const QVector&lt; double &gt; &amp;valueErrorMinus, const QVector&lt; double &gt; &amp;valueErrorPlus)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a> (<a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">LineStyle</a> ls)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a06373e09547bcfe237dd8ebcbe5c255a">setScatterStyle</a> (<a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26f">QCP::ScatterStyle</a> ss)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a70d5c6058096797a227e6827ff743d89">setScatterSize</a> (double size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a80131c36eb134fbfb603951ef70e0a19">setScatterPixmap</a> (const QPixmap &amp;pixmap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a> (<a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a> errorType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abd4c7f81939e10776ea64603a704f22a">setErrorPen</a> (const QPen &amp;pen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a10f50c5495ce45ef559ec2066194a335">setErrorBarSize</a> (double size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab1c1ee03d8dd94676a564e5e5f11aac2">setErrorBarSkipSymbol</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a2d03156df1b64037a2e36cfa50351ca3">setChannelFillGraph</a> (<a class="el" href="classQCPGraph.html">QCPGraph</a> *targetGraph)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a> (const <a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> &amp;dataMap)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a80cc91e1e0ef77eb50afc5b366d0efd9">addData</a> (const <a class="el" href="classQCPData.html">QCPData</a> &amp;data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0bf98b1972286cfb7b1c4b7dd6ae2012">addData</a> (double key, double value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab6da6377541fe80d892a9893a92db9c6">addData</a> (const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a9fe0b3e54e8c7b61319bd03337e21e99">removeDataBefore</a> (double key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ae42d645ef617cfc75fc0df58e62c522a">removeDataAfter</a> (double key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> (double fromKey, double toKey)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a4a706020b4318f118381648ef18aca3f">removeData</a> (double key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a9a95048dc6daf83e45efbf6d2cdc92d7">selectTest</a> (const QPointF &amp;pos) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#aa35b75b9032800d783df749c8a004ee9">rescaleAxes</a> (bool onlyEnlarge, bool includeErrorBars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a2108a729046b0ab6e0516afb249dab13">rescaleKeyAxis</a> (bool onlyEnlarge, bool includeErrorBars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a2ba0e1df416486d7e74299ef8cf68bba">rescaleValueAxis</a> (bool onlyEnlarge, bool includeErrorBars) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1affc1972938e4364a9325e4e4e4dcea"></a><!-- doxytag: member="QCPGraph::name" ref="a1affc1972938e4364a9325e4e4e4dcea" args="() const " -->
QString&#160;</td><td class="memItemRight" valign="bottom"><b>name</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a68d1c358db03faae376ec47c589abf27"></a><!-- doxytag: member="QCPGraph::antialiasedFill" ref="a68d1c358db03faae376ec47c589abf27" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>antialiasedFill</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefc379bcc011660a5371ecc6088a97eb"></a><!-- doxytag: member="QCPGraph::antialiasedScatters" ref="aefc379bcc011660a5371ecc6088a97eb" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>antialiasedScatters</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a630cfb27ff99ab4373b09631748fcf4a"></a><!-- doxytag: member="QCPGraph::antialiasedErrorBars" ref="a630cfb27ff99ab4373b09631748fcf4a" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>antialiasedErrorBars</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a41d060007cc6b3037c9c04d22d0c0398"></a><!-- doxytag: member="QCPGraph::pen" ref="a41d060007cc6b3037c9c04d22d0c0398" args="() const " -->
QPen&#160;</td><td class="memItemRight" valign="bottom"><b>pen</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a006065572c5add883a944ea4cda699f3"></a><!-- doxytag: member="QCPGraph::selectedPen" ref="a006065572c5add883a944ea4cda699f3" args="() const " -->
QPen&#160;</td><td class="memItemRight" valign="bottom"><b>selectedPen</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa74cdceb9c7286ef116fbfa58e0326e7"></a><!-- doxytag: member="QCPGraph::brush" ref="aa74cdceb9c7286ef116fbfa58e0326e7" args="() const " -->
QBrush&#160;</td><td class="memItemRight" valign="bottom"><b>brush</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a403745791879916431adc872b49207e5"></a><!-- doxytag: member="QCPGraph::selectedBrush" ref="a403745791879916431adc872b49207e5" args="() const " -->
QBrush&#160;</td><td class="memItemRight" valign="bottom"><b>selectedBrush</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72c7a09c22963f2c943f07112b311103"></a><!-- doxytag: member="QCPGraph::keyAxis" ref="a72c7a09c22963f2c943f07112b311103" args="() const " -->
<a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>keyAxis</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3106f9d34d330a6097a8ec5905e5b519"></a><!-- doxytag: member="QCPGraph::valueAxis" ref="a3106f9d34d330a6097a8ec5905e5b519" args="() const " -->
<a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>valueAxis</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af895574da1ec0d050711b6c9deda296a"></a><!-- doxytag: member="QCPGraph::selectable" ref="af895574da1ec0d050711b6c9deda296a" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>selectable</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab901903adcb0e29467d63de72340ab29"></a><!-- doxytag: member="QCPGraph::selected" ref="ab901903adcb0e29467d63de72340ab29" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>selected</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ab79c7ba76bc7fa89a4b3580e12149f1f">setName</a> (const QString &amp;name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a089d6b5577120239b55c39ed27c39536">setAntialiasedFill</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a2f03f067ede2ed4da6f7d0e4777a3f02">setAntialiasedScatters</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a757beb744b96cf1855cca5ab9d3ecf52">setAntialiasedErrorBars</a> (bool enabled)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a> (const QPen &amp;pen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a6911603cad23ab0469b108224517516f">setSelectedPen</a> (const QPen &amp;pen)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a> (const QBrush &amp;brush)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ae8c816874089f7a44001e8618e81a9dc">setSelectedBrush</a> (const QBrush &amp;brush)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a8524fa2994c63c0913ebd9bb2ffa3920">setKeyAxis</a> (<a class="el" href="classQCPAxis.html">QCPAxis</a> *axis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a71626a07367e241ec62ad2c34baf21cb">setValueAxis</a> (<a class="el" href="classQCPAxis.html">QCPAxis</a> *axis)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a22c69299eb5569e0f6bf084877a37dc4">setSelectable</a> (bool selectable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#afbd5428c2952f59d952e11ab5cd79176">setSelected</a> (bool selected)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a7e8fc3be43c27ccacd70a7bf9d74a5cd">rescaleAxes</a> (bool onlyEnlarge=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a1acecfcca3e7fcda00fcbaa3c886386f">rescaleKeyAxis</a> (bool onlyEnlarge=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#abfd0805eb1d955c0111a990246658324">rescaleValueAxis</a> (bool onlyEnlarge=false) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a70f8cabfd808f7d5204b9f18c45c13f5">addToLegend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#aa1f350e510326d012b9a9c9249736c83">removeFromLegend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10a3cc92e0fa63e4a929e61d34e275a7"></a><!-- doxytag: member="QCPGraph::visible" ref="a10a3cc92e0fa63e4a929e61d34e275a7" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>visible</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab7e0e94461566093d36ffc0f5312b109"></a><!-- doxytag: member="QCPGraph::parentPlot" ref="ab7e0e94461566093d36ffc0f5312b109" args="() const " -->
<a class="el" href="classQCustomPlot.html">QCustomPlot</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>parentPlot</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aea67e8c19145e70d68c286a36f6b8300"></a><!-- doxytag: member="QCPGraph::layer" ref="aea67e8c19145e70d68c286a36f6b8300" args="() const " -->
<a class="el" href="classQCPLayer.html">QCPLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>layer</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef5cb4aa899ed9dc9384fd614560291e"></a><!-- doxytag: member="QCPGraph::antialiased" ref="aef5cb4aa899ed9dc9384fd614560291e" args="() const " -->
bool&#160;</td><td class="memItemRight" valign="bottom"><b>antialiased</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a3bed99ddc396b48ce3ebfdc0418744f8">setVisible</a> (bool on)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#ab0d0da6d2de45a118886d2c8e16d5a54">setLayer</a> (<a class="el" href="classQCPLayer.html">QCPLayer</a> *layer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#ab25a0e7b897993b44447caee0f142083">setLayer</a> (const QString &amp;layerName)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">setAntialiased</a> (bool enabled)</td></tr>
<tr><td colspan="2"><h2><a name="signals"></a>
Signals</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a3af66432b1dca93b28e00e78a8c7c1d9">selectionChanged</a> (bool selected)</td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> </td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>
Protected Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a659218cc62c2a7786213d9dd429c1c8d">draw</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a9a1a3d937a35368c421657860aa5a173">drawLegendIcon</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, const QRect &amp;rect) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#af66183533a29520be3e74489ad1449cc">getPlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0899c4d6357aee19a3abff5897c3c8c5">getScatterPlotData</a> (QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ac76804eb33446181f3e4f708b7639a75">getLinePlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a6b7c14e04deed69b70d552dbe70c4d28">getStepLeftPlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab2ad46716889c73ab977cf9280de0788">getStepRightPlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ac79dc75dd98db9948d9656447b463af5">getStepCenterPlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0ff6e856387cc079b28592ead2a81f6c">getImpulsePlotData</a> (QVector&lt; QPointF &gt; *lineData, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad6d07926e6d6b7cfa70258780d47b7a0">drawFill</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#af1872a60bed7acb3f3b17bfae3f4764c">drawScatterPlot</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *pointData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abc01180629621f1e47e94559227d3d8c">drawImpulsePlot</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a4df6807066ce877705e999773e7ffbc4">drawError</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, double x, double y, const <a class="el" href="classQCPData.html">QCPData</a> &amp;data) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a8963c90087cf53b889b29dd59aa41aad">getVisibleDataBounds</a> (QCPDataMap::const_iterator &amp;lower, QCPDataMap::const_iterator &amp;upper, int &amp;count) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a> (QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ad31b49a90e91e538fd9caf011c913a68">removeFillBasePoints</a> (QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QPointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">lowerFillBasePoint</a> (double lowerKey) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QPointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">upperFillBasePoint</a> (double upperKey) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QPolygonF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a> (const QVector&lt; QPointF &gt; *lineData) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a6f4e9461d5925be9228fc4760249a04f">findIndexBelowX</a> (const QVector&lt; QPointF &gt; *data, double x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#abab2a75b5e63630432bdd1f3b57f07fa">findIndexAboveX</a> (const QVector&lt; QPointF &gt; *data, double x) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a6c4d556de3d1e02f548401001f72c6ff">findIndexBelowY</a> (const QVector&lt; QPointF &gt; *data, double y) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#adf50243f1df203883a2187089734bfcb">findIndexAboveY</a> (const QVector&lt; QPointF &gt; *data, double y) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#af93762a12a481a7edb4b3dd9e330dff1">pointDistance</a> (const QPointF &amp;pixelPoint) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#ab39c7e8c94b64804a8dc9c19bc7d4683">getKeyRange</a> (bool &amp;validRange, <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> inSignDomain=<a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60">sdBoth</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a9fc0c1288455fa5bb64b603d6b01de6c">getValueRange</a> (bool &amp;validRange, <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> inSignDomain=<a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60">sdBoth</a>) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#a3a69fbbaea30050a9cfe335a9a01cbf2">getKeyRange</a> (bool &amp;validRange, <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> inSignDomain, bool includeErrors) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classQCPRange.html">QCPRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPGraph.html#acdb1e7bb86fea2764b0adb104185832b">getValueRange</a> (bool &amp;validRange, <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a> inSignDomain, bool includeErrors) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QRect&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ac01960b0827913922f5364d559c124ed">clipRect</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ade710a776104b14c1c835168ce1bfc5c">coordsToPixels</a> (double key, double value, double &amp;x, double &amp;y) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const QPointF&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a9fd1c9df8391781f05b0be22fbe91e13">coordsToPixels</a> (double key, double value) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a10408828446e9e0681c46d65120f382e">pixelsToCoords</a> (double x, double y, double &amp;key, double &amp;value) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a3e2c361cfcdfd5d803ada4d333a07e15">pixelsToCoords</a> (const QPointF &amp;pixelPos, double &amp;key, double &amp;value) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QPen&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a19276ed2382a3a06464417b8788b1451">mainPen</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QBrush&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ae74c123832da180c17e22203e748d9b7">mainBrush</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a76e9d6cc7972dc1528f526d163766aca">applyDefaultAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#ac08a480155895e674dbfe5a5670e0ff3">applyFillAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a753272ee225a62827e90c3e1e78de4b1">applyScattersAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#af687bfe6160255960558eb71f1f81e73">applyErrorBarsAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPAbstractPlottable.html#a5ea1cab44ca912dcdc96ed81ec5bed5d">distSqrToLine</a> (const QPointF &amp;start, const QPointF &amp;end, const QPointF &amp;point) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#af94484cfb7cbbddb7de522e9be71d9a4">moveToLayer</a> (<a class="el" href="classQCPLayer.html">QCPLayer</a> *layer, bool prepend)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classQCPLayerable.html#a62bd552d1a45aa9accb24b310542279e">applyAntialiasingHint</a> (<a class="el" href="classQCPPainter.html">QCPPainter</a> *painter, bool localAntialiased, <a class="el" href="namespaceQCP.html#ae55dbe315d41fe80f29ba88100843a0c">QCP::AntialiasedElement</a> overrideElement) const </td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A plottable representing a graph in a plot. </p>
<p>Usually <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> creates it internally via <a class="el" href="classQCustomPlot.html#a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</a> and the resulting instance is accessed via <a class="el" href="classQCustomPlot.html#a6d3ed93c2bf46ab7fa670d66be4cddaf">QCustomPlot::graph</a>.</p>
<p>To plot data, assign it with the <a class="el" href="classQCPGraph.html#a1df2fd710545c8ba3b2c99a39a27bf8b">setData</a> or <a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a> functions.</p>
<h2><a class="anchor" id="appearance"></a>
Changing the appearance</h2>
<p>The appearance of the graph is mainly determined by the line style, scatter style, brush and pen of the graph (<a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a>, <a class="el" href="classQCPGraph.html#a06373e09547bcfe237dd8ebcbe5c255a">setScatterStyle</a>, <a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a>, <a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a>).</p>
<h3><a class="anchor" id="filling"></a>
Filling under or between graphs</h3>
<p><a class="el" href="classQCPGraph.html" title="A plottable representing a graph in a plot.">QCPGraph</a> knows two types of fills: Normal graph fills towards the zero-value-line parallel to the key axis of the graph, and fills between two graphs, called channel fills. To enable a fill, just set a brush with <a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a> which is neither Qt::NoBrush nor fully transparent.</p>
<p>By default, a normal fill towards the zero-value-line will be drawn. To set up a channel fill between this graph and another one, call <a class="el" href="classQCPGraph.html#a2d03156df1b64037a2e36cfa50351ca3">setChannelFillGraph</a> with the other graph as parameter.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCustomPlot.html#a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</a>, <a class="el" href="classQCustomPlot.html#a6d3ed93c2bf46ab7fa670d66be4cddaf">QCustomPlot::graph</a>, QCPLegend::addGraph </dd></dl>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859"></a><!-- doxytag: member="QCPGraph::LineStyle" ref="ad60175cd9b5cac937c5ee685c32c0859" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">QCPGraph::LineStyle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines how the graph's line is represented visually in the plot. The line is drawn with the current pen of the graph (<a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a>). </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04"></a><!-- doxytag: member="lsNone" ref="ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04" args="" -->lsNone</em>&nbsp;</td><td>
<p>data points are not connected with any lines (e.g. data only represented with symbols according to the scatter style, see <a class="el" href="classQCPGraph.html#a06373e09547bcfe237dd8ebcbe5c255a">setScatterStyle</a>) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859a3c42a27b15aa3c92d399082fad8b7515"></a><!-- doxytag: member="lsLine" ref="ad60175cd9b5cac937c5ee685c32c0859a3c42a27b15aa3c92d399082fad8b7515" args="" -->lsLine</em>&nbsp;</td><td>
<p>data points are connected by a straight line </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859ae10568bda57836487d9dec5eba1d6c6e"></a><!-- doxytag: member="lsStepLeft" ref="ad60175cd9b5cac937c5ee685c32c0859ae10568bda57836487d9dec5eba1d6c6e" args="" -->lsStepLeft</em>&nbsp;</td><td>
<p>line is drawn as steps where the step height is the value of the left data point </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859a9c37951f7d11aa070100fd16f2935c9e"></a><!-- doxytag: member="lsStepRight" ref="ad60175cd9b5cac937c5ee685c32c0859a9c37951f7d11aa070100fd16f2935c9e" args="" -->lsStepRight</em>&nbsp;</td><td>
<p>line is drawn as steps where the step height is the value of the right data point </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859a5adf7b04da215a40a764c21294ea7366"></a><!-- doxytag: member="lsStepCenter" ref="ad60175cd9b5cac937c5ee685c32c0859a5adf7b04da215a40a764c21294ea7366" args="" -->lsStepCenter</em>&nbsp;</td><td>
<p>line is drawn as steps where the step is in between two data points </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad60175cd9b5cac937c5ee685c32c0859aa3b358b4ae7cca94aceeb8e529c12ebb"></a><!-- doxytag: member="lsImpulse" ref="ad60175cd9b5cac937c5ee685c32c0859aa3b358b4ae7cca94aceeb8e529c12ebb" args="" -->lsImpulse</em>&nbsp;</td><td>
<p>each data point is represented by a line parallel to the value axis, which reaches from the data point to the zero-value-line </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad23b514404bd2cb3216f57c90904d6af"></a><!-- doxytag: member="QCPGraph::ErrorType" ref="ad23b514404bd2cb3216f57c90904d6af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">QCPGraph::ErrorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Defines what kind of error bars are drawn for each data point </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad23b514404bd2cb3216f57c90904d6afaeae745e7cc1766bb8546e35d4b76a711"></a><!-- doxytag: member="etNone" ref="ad23b514404bd2cb3216f57c90904d6afaeae745e7cc1766bb8546e35d4b76a711" args="" -->etNone</em>&nbsp;</td><td>
<p>No error bars are shown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad23b514404bd2cb3216f57c90904d6afa2a5d89cd76fb8b6b18d71b8f6f6c0f43"></a><!-- doxytag: member="etKey" ref="ad23b514404bd2cb3216f57c90904d6afa2a5d89cd76fb8b6b18d71b8f6f6c0f43" args="" -->etKey</em>&nbsp;</td><td>
<p>Error bars for the key dimension of the data point are shown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad23b514404bd2cb3216f57c90904d6afa147022ccdc49f6bd48f904cb4f61872e"></a><!-- doxytag: member="etValue" ref="ad23b514404bd2cb3216f57c90904d6afa147022ccdc49f6bd48f904cb4f61872e" args="" -->etValue</em>&nbsp;</td><td>
<p>Error bars for the value dimension of the data point are shown. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ad23b514404bd2cb3216f57c90904d6afa761cb7d61670c1e2efecccd8974409ab"></a><!-- doxytag: member="etBoth" ref="ad23b514404bd2cb3216f57c90904d6afa761cb7d61670c1e2efecccd8974409ab" args="" -->etBoth</em>&nbsp;</td><td>
<p>Error bars for both key and value dimensions of the data point are shown. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a661743478a1d3c09d28ec2711d7653d8"></a><!-- doxytag: member="QCPGraph::SignDomain" ref="a661743478a1d3c09d28ec2711d7653d8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">QCPAbstractPlottable::SignDomain</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Represents negative and positive sign domain for passing to <a class="el" href="classQCPAbstractPlottable.html#a7aa24ed0b3c39bd99338c7b9f145a71b">getKeyRange</a> and <a class="el" href="classQCPAbstractPlottable.html#aed35cfebe5546feea7af2638dd869d5f">getValueRange</a>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63"></a><!-- doxytag: member="sdNegative" ref="a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63" args="" -->sdNegative</em>&nbsp;</td><td>
<p>The negative sign domain, i.e. numbers smaller than zero. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60"></a><!-- doxytag: member="sdBoth" ref="a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60" args="" -->sdBoth</em>&nbsp;</td><td>
<p>Both sign domains, including zero, i.e. all (rational) numbers. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a661743478a1d3c09d28ec2711d7653d8a02951859f243a4d24e779cfbb5471030"></a><!-- doxytag: member="sdPositive" ref="a661743478a1d3c09d28ec2711d7653d8a02951859f243a4d24e779cfbb5471030" args="" -->sdPositive</em>&nbsp;</td><td>
<p>The positive sign domain, i.e. numbers greater than zero. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0393a38cf7183cbf46348eb6cf9a5a6c"></a><!-- doxytag: member="QCPGraph::QCPGraph" ref="a0393a38cf7183cbf46348eb6cf9a5a6c" args="(QCPAxis *keyAxis, QCPAxis *valueAxis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPGraph.html#a0393a38cf7183cbf46348eb6cf9a5a6c">QCPGraph::QCPGraph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td>
          <td class="paramname"><em>keyAxis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td>
          <td class="paramname"><em>valueAxis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Constructs a graph which uses <em>keyAxis</em> as its key axis ("x") and <em>valueAxis</em> as its value axis ("y"). <em>keyAxis</em> and <em>valueAxis</em> must reside in the same <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> instance and not have the same orientation. If either of these restrictions is violated, a corresponding message is printed to the debug output (qDebug), the construction is not aborted, though.</p>
<p>The constructed <a class="el" href="classQCPGraph.html" title="A plottable representing a graph in a plot.">QCPGraph</a> can be added to the plot with <a class="el" href="classQCustomPlot.html#ab7ad9174f701f9c6f64e378df77927a6">QCustomPlot::addPlottable</a>, <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> then takes ownership of the graph.</p>
<p>To directly create a graph inside a plot, you can also use the simpler <a class="el" href="classQCustomPlot.html#a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</a> function. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a1df2fd710545c8ba3b2c99a39a27bf8b"></a><!-- doxytag: member="QCPGraph::setData" ref="a1df2fd710545c8ba3b2c99a39a27bf8b" args="(QCPDataMap *data, bool copy=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a1df2fd710545c8ba3b2c99a39a27bf8b">QCPGraph::setData</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the current data with the provided <em>data</em>.</p>
<p>If <em>copy</em> is set to true, data points in <em>data</em> will only be copied. if false, the graph takes ownership of the passed data and replaces the internal data pointer with it. This is significantly faster than copying for large datasets. </p>

</div>
</div>
<a class="anchor" id="a4c55d8ac13bfa42c8c93747820891a76"></a><!-- doxytag: member="QCPGraph::setData" ref="a4c55d8ac13bfa42c8c93747820891a76" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a1df2fd710545c8ba3b2c99a39a27bf8b">QCPGraph::setData</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="abce9f07c0d722bc3e4fa7bd73c7e5dfa"></a><!-- doxytag: member="QCPGraph::setDataKeyError" ref="abce9f07c0d722bc3e4fa7bd73c7e5dfa" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#abce9f07c0d722bc3e4fa7bd73c7e5dfa">QCPGraph::setDataKeyError</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the symmetrical key error of the data points are set to the values in <em>keyError</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.</p>
<p>For asymmetrical errors (plus different from minus), see the overloaded version of this function. </p>

</div>
</div>
<a class="anchor" id="ac15c749c5fedf740d5692c6fe67143b8"></a><!-- doxytag: member="QCPGraph::setDataKeyError" ref="ac15c749c5fedf740d5692c6fe67143b8" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyErrorMinus, const QVector&lt; double &gt; &amp;keyErrorPlus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#abce9f07c0d722bc3e4fa7bd73c7e5dfa">QCPGraph::setDataKeyError</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyErrorMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyErrorPlus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the negative key error of the data points are set to the values in <em>keyErrorMinus</em>, the positive key error to <em>keyErrorPlus</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="acba6296eadcb36b93267628b8dae3de5"></a><!-- doxytag: member="QCPGraph::setDataValueError" ref="acba6296eadcb36b93267628b8dae3de5" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;valueError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#acba6296eadcb36b93267628b8dae3de5">QCPGraph::setDataValueError</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the symmetrical value error of the data points are set to the values in <em>valueError</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.</p>
<p>For asymmetrical errors (plus different from minus), see the overloaded version of this function. </p>

</div>
</div>
<a class="anchor" id="a3afbfd7222d739351c69387904776f93"></a><!-- doxytag: member="QCPGraph::setDataValueError" ref="a3afbfd7222d739351c69387904776f93" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;valueErrorMinus, const QVector&lt; double &gt; &amp;valueErrorPlus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#acba6296eadcb36b93267628b8dae3de5">QCPGraph::setDataValueError</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueErrorMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueErrorPlus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the negative value error of the data points are set to the values in <em>valueErrorMinus</em>, the positive value error to <em>valueErrorPlus</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="a873fe46bdb20be5710428e474ade8908"></a><!-- doxytag: member="QCPGraph::setDataBothError" ref="a873fe46bdb20be5710428e474ade8908" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyError, const QVector&lt; double &gt; &amp;valueError)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a873fe46bdb20be5710428e474ade8908">QCPGraph::setDataBothError</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueError</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the symmetrical key and value errors of the data points are set to the values in <em>keyError</em> and <em>valueError</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector.</p>
<p>For asymmetrical errors (plus different from minus), see the overloaded version of this function. </p>

</div>
</div>
<a class="anchor" id="abb75736ecdbf6e6a7501e1da64fb18cf"></a><!-- doxytag: member="QCPGraph::setDataBothError" ref="abb75736ecdbf6e6a7501e1da64fb18cf" args="(const QVector&lt; double &gt; &amp;key, const QVector&lt; double &gt; &amp;value, const QVector&lt; double &gt; &amp;keyErrorMinus, const QVector&lt; double &gt; &amp;keyErrorPlus, const QVector&lt; double &gt; &amp;valueErrorMinus, const QVector&lt; double &gt; &amp;valueErrorPlus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a873fe46bdb20be5710428e474ade8908">QCPGraph::setDataBothError</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyErrorMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keyErrorPlus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueErrorMinus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>valueErrorPlus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Replaces the current data with the provided points in <em>key</em> and <em>value</em> pairs. Additionally the negative key and value errors of the data points are set to the values in <em>keyErrorMinus</em> and <em>valueErrorMinus</em>. The positive key and value errors are set to the values in <em>keyErrorPlus</em> <em>valueErrorPlus</em>. For error bars to show appropriately, see <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a>. The provided vectors should have equal length. Else, the number of added points will be the size of the smallest vector. </p>

</div>
</div>
<a class="anchor" id="a513fecccff5b2a50ce53f665338c60ff"></a><!-- doxytag: member="QCPGraph::setLineStyle" ref="a513fecccff5b2a50ce53f665338c60ff" args="(LineStyle ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">QCPGraph::setLineStyle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859">LineStyle</a>&#160;</td>
          <td class="paramname"><em>ls</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets how the single data points are connected in the plot or how they are represented visually apart from the scatter symbol. For scatter-only plots, set <em>ls</em> to <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</a> and <a class="el" href="classQCPGraph.html#a06373e09547bcfe237dd8ebcbe5c255a">setScatterStyle</a> to the desired scatter style.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a06373e09547bcfe237dd8ebcbe5c255a">setScatterStyle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a06373e09547bcfe237dd8ebcbe5c255a"></a><!-- doxytag: member="QCPGraph::setScatterStyle" ref="a06373e09547bcfe237dd8ebcbe5c255a" args="(QCP::ScatterStyle ss)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a06373e09547bcfe237dd8ebcbe5c255a">QCPGraph::setScatterStyle</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26f">QCP::ScatterStyle</a>&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the visual appearance of single data points in the plot. If set to <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>, no scatter points are drawn (e.g. for line-only-plots with appropriate line style).</p>
<dl class="see"><dt><b>See also:</b></dt><dd>ScatterStyle, <a class="el" href="classQCPGraph.html#a513fecccff5b2a50ce53f665338c60ff">setLineStyle</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70d5c6058096797a227e6827ff743d89"></a><!-- doxytag: member="QCPGraph::setScatterSize" ref="a70d5c6058096797a227e6827ff743d89" args="(double size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a70d5c6058096797a227e6827ff743d89">QCPGraph::setScatterSize</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This defines how big (in pixels) single scatters are drawn, if scatter style (<a class="el" href="classQCPGraph.html#a06373e09547bcfe237dd8ebcbe5c255a">setScatterStyle</a>) isn't <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>, <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa56816c1386f1356417bcc013adf0367c">QCP::ssDot</a> or <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3046d385199d0903dd492322ba133e75">QCP::ssPixmap</a>. Floating point values are allowed for fine grained control over optical appearance with antialiased painting.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>ScatterStyle </dd></dl>

</div>
</div>
<a class="anchor" id="a80131c36eb134fbfb603951ef70e0a19"></a><!-- doxytag: member="QCPGraph::setScatterPixmap" ref="a80131c36eb134fbfb603951ef70e0a19" args="(const QPixmap &amp;pixmap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a80131c36eb134fbfb603951ef70e0a19">QCPGraph::setScatterPixmap</a> </td>
          <td>(</td>
          <td class="paramtype">const QPixmap &amp;&#160;</td>
          <td class="paramname"><em>pixmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If the scatter style (<a class="el" href="classQCPGraph.html#a06373e09547bcfe237dd8ebcbe5c255a">setScatterStyle</a>) is set to ssPixmap, this function defines the QPixmap that will be drawn centered on the data point coordinate.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>ScatterStyle </dd></dl>

</div>
</div>
<a class="anchor" id="ac3614d799c3894f2bc646e99c7f73d38"></a><!-- doxytag: member="QCPGraph::setErrorType" ref="ac3614d799c3894f2bc646e99c7f73d38" args="(ErrorType errorType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">QCPGraph::setErrorType</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a>&#160;</td>
          <td class="paramname"><em>errorType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets which kind of error bars (Key Error, Value Error or both) should be drawn on each data point. If you set <em>errorType</em> to something other than <a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6afaeae745e7cc1766bb8546e35d4b76a711">etNone</a>, make sure to actually pass error data via the specific setData functions along with the data points (e.g. <a class="el" href="classQCPGraph.html#acba6296eadcb36b93267628b8dae3de5">setDataValueError</a>, <a class="el" href="classQCPGraph.html#abce9f07c0d722bc3e4fa7bd73c7e5dfa">setDataKeyError</a>, <a class="el" href="classQCPGraph.html#a873fe46bdb20be5710428e474ade8908">setDataBothError</a>).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6af">ErrorType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abd4c7f81939e10776ea64603a704f22a"></a><!-- doxytag: member="QCPGraph::setErrorPen" ref="abd4c7f81939e10776ea64603a704f22a" args="(const QPen &amp;pen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#abd4c7f81939e10776ea64603a704f22a">QCPGraph::setErrorPen</a> </td>
          <td>(</td>
          <td class="paramtype">const QPen &amp;&#160;</td>
          <td class="paramname"><em>pen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the pen with which the error bars will be drawn. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a10f50c5495ce45ef559ec2066194a335">setErrorBarSize</a>, <a class="el" href="classQCPGraph.html#ac3614d799c3894f2bc646e99c7f73d38">setErrorType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a10f50c5495ce45ef559ec2066194a335"></a><!-- doxytag: member="QCPGraph::setErrorBarSize" ref="a10f50c5495ce45ef559ec2066194a335" args="(double size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a10f50c5495ce45ef559ec2066194a335">QCPGraph::setErrorBarSize</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the width of the handles at both ends of an error bar in pixels. </p>

</div>
</div>
<a class="anchor" id="ab1c1ee03d8dd94676a564e5e5f11aac2"></a><!-- doxytag: member="QCPGraph::setErrorBarSkipSymbol" ref="ab1c1ee03d8dd94676a564e5e5f11aac2" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ab1c1ee03d8dd94676a564e5e5f11aac2">QCPGraph::setErrorBarSkipSymbol</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If <em>enabled</em> is set to true, the error bar will not be drawn as a solid line under the scatter symbol but leave some free space around the symbol.</p>
<p>This feature uses the current scatter size (<a class="el" href="classQCPGraph.html#a70d5c6058096797a227e6827ff743d89">setScatterSize</a>) to determine the size of the area to leave blank. So when drawing Pixmaps as scatter points (<a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3046d385199d0903dd492322ba133e75">QCP::ssPixmap</a>), the scatter size must be set manually to a value corresponding to the size of the Pixmap, if the error bars should leave gaps to its boundaries. </p>

</div>
</div>
<a class="anchor" id="a2d03156df1b64037a2e36cfa50351ca3"></a><!-- doxytag: member="QCPGraph::setChannelFillGraph" ref="a2d03156df1b64037a2e36cfa50351ca3" args="(QCPGraph *targetGraph)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a2d03156df1b64037a2e36cfa50351ca3">QCPGraph::setChannelFillGraph</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPGraph.html">QCPGraph</a> *&#160;</td>
          <td class="paramname"><em>targetGraph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the target graph for filling the area between this graph and <em>targetGraph</em> with the current brush (<a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a>).</p>
<p>When <em>targetGraph</em> is set to 0, a normal graph fill will be produced. This means, when the brush is not Qt::NoBrush or fully transparent, a fill all the way to the zero-value-line parallel to the key axis of this graph will be drawn. To disable any filling, set the brush to Qt::NoBrush. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5c6181d84db72ce4dbe9dc15a34ef4f"></a><!-- doxytag: member="QCPGraph::addData" ref="aa5c6181d84db72ce4dbe9dc15a34ef4f" args="(const QCPDataMap &amp;dataMap)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">QCPGraph::addData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="qcustomplot_8h.html#a84a9c4a4c2216ccfdcb5f3067cda76e3">QCPDataMap</a> &amp;&#160;</td>
          <td class="paramname"><em>dataMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds the provided data points in <em>dataMap</em> to the current data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a80cc91e1e0ef77eb50afc5b366d0efd9"></a><!-- doxytag: member="QCPGraph::addData" ref="a80cc91e1e0ef77eb50afc5b366d0efd9" args="(const QCPData &amp;data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">QCPGraph::addData</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classQCPData.html">QCPData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Adds the provided single data point in <em>data</em> to the current data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0bf98b1972286cfb7b1c4b7dd6ae2012"></a><!-- doxytag: member="QCPGraph::addData" ref="a0bf98b1972286cfb7b1c4b7dd6ae2012" args="(double key, double value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">QCPGraph::addData</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Adds the provided single data point as <em>key</em> and <em>value</em> pair to the current data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab6da6377541fe80d892a9893a92db9c6"></a><!-- doxytag: member="QCPGraph::addData" ref="ab6da6377541fe80d892a9893a92db9c6" args="(const QVector&lt; double &gt; &amp;keys, const QVector&lt; double &gt; &amp;values)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">QCPGraph::addData</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Adds the provided data points as <em>key</em> and <em>value</em> pairs to the current data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9fe0b3e54e8c7b61319bd03337e21e99"></a><!-- doxytag: member="QCPGraph::removeDataBefore" ref="a9fe0b3e54e8c7b61319bd03337e21e99" args="(double key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a9fe0b3e54e8c7b61319bd03337e21e99">QCPGraph::removeDataBefore</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all data points with keys smaller than <em>key</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a>, <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae42d645ef617cfc75fc0df58e62c522a"></a><!-- doxytag: member="QCPGraph::removeDataAfter" ref="ae42d645ef617cfc75fc0df58e62c522a" args="(double key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ae42d645ef617cfc75fc0df58e62c522a">QCPGraph::removeDataAfter</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all data points with keys greater than <em>key</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a>, <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a0fde50b7db9db0a85b5c5b6b10098f"></a><!-- doxytag: member="QCPGraph::removeData" ref="a4a0fde50b7db9db0a85b5c5b6b10098f" args="(double fromKey, double toKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">QCPGraph::removeData</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fromKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>toKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all data points with keys between <em>fromKey</em> and <em>toKey</em>. if <em>fromKey</em> is greater or equal to <em>toKey</em>, the function does nothing. To remove a single data point with known key, use <a class="el" href="classQCPGraph.html#a4a706020b4318f118381648ef18aca3f">removeData(double key)</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a>, <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a706020b4318f118381648ef18aca3f"></a><!-- doxytag: member="QCPGraph::removeData" ref="a4a706020b4318f118381648ef18aca3f" args="(double key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">QCPGraph::removeData</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Removes a single data point at <em>key</em>. If the position is not known with absolute precision, consider using <a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData(double fromKey, double toKey)</a> with a small fuzziness interval around the suspected position, depeding on the precision with which the key is known.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa5c6181d84db72ce4dbe9dc15a34ef4f">addData</a>, <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">clearData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad4e94a4e44e5e76fbec81a72a977157d"></a><!-- doxytag: member="QCPGraph::clearData" ref="ad4e94a4e44e5e76fbec81a72a977157d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ad4e94a4e44e5e76fbec81a72a977157d">QCPGraph::clearData</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes all data points. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a4a0fde50b7db9db0a85b5c5b6b10098f">removeData</a>, <a class="el" href="classQCPGraph.html#ae42d645ef617cfc75fc0df58e62c522a">removeDataAfter</a>, <a class="el" href="classQCPGraph.html#a9fe0b3e54e8c7b61319bd03337e21e99">removeDataBefore</a> </dd></dl>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#a86e5b8fd4b6ff4f4084e7ea4c573fc53">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="a9a95048dc6daf83e45efbf6d2cdc92d7"></a><!-- doxytag: member="QCPGraph::selectTest" ref="a9a95048dc6daf83e45efbf6d2cdc92d7" args="(const QPointF &amp;pos) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classQCPGraph.html#a9a95048dc6daf83e45efbf6d2cdc92d7">QCPGraph::selectTest</a> </td>
          <td>(</td>
          <td class="paramtype">const QPointF &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is used to decide whether a click hits a plottable or not.</p>
<p><em>pos</em> is a point in pixel coordinates on the <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> surface. This function returns the shortest pixel distance of this point to the plottable (e.g. to the scatters/lines of a graph). If the plottable is either invisible, contains no data or the distance couldn't be determined, -1.0 is returned. <a class="el" href="classQCPAbstractPlottable.html#a22c69299eb5569e0f6bf084877a37dc4">setSelectable</a> has no influence on the return value of this function.</p>
<p>If the plottable is represented not by single lines but by an area like <a class="el" href="classQCPBars.html" title="A plottable representing a bar chart in a plot.">QCPBars</a> or <a class="el" href="classQCPStatisticalBox.html" title="A plottable representing a single statistical box in a plot.">QCPStatisticalBox</a>, a click inside the area returns a constant value greater zero (typically 99% of the selectionTolerance of the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>). If the click lies outside the area, this function returns -1.0.</p>
<p>Providing a constant value for area objects allows selecting line objects even when they are obscured by such area objects, by clicking close to the lines (i.e. closer than 0.99*selectionTolerance).</p>
<p>The actual setting of the selection state is not done by this function. This is handled by the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> when the mouseReleaseEvent occurs.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#afbd5428c2952f59d952e11ab5cd79176">setSelected</a>, <a class="el" href="classQCustomPlot.html#add9cc886ff5257f64fb4117cf6c135fe">QCustomPlot::setInteractions</a> </dd></dl>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#a0fd218d6c4974b6ab05bd2f688818556">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="aa35b75b9032800d783df749c8a004ee9"></a><!-- doxytag: member="QCPGraph::rescaleAxes" ref="aa35b75b9032800d783df749c8a004ee9" args="(bool onlyEnlarge, bool includeErrorBars) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#aa35b75b9032800d783df749c8a004ee9">QCPGraph::rescaleAxes</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrorBars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to define whether error bars are taken into consideration when determining the new axis range. </p>

</div>
</div>
<a class="anchor" id="a2108a729046b0ab6e0516afb249dab13"></a><!-- doxytag: member="QCPGraph::rescaleKeyAxis" ref="a2108a729046b0ab6e0516afb249dab13" args="(bool onlyEnlarge, bool includeErrorBars) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a2108a729046b0ab6e0516afb249dab13">QCPGraph::rescaleKeyAxis</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrorBars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to define whether error bars (of kind <a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6afa2a5d89cd76fb8b6b18d71b8f6f6c0f43">QCPGraph::etKey</a>) are taken into consideration when determining the new axis range. </p>

</div>
</div>
<a class="anchor" id="a2ba0e1df416486d7e74299ef8cf68bba"></a><!-- doxytag: member="QCPGraph::rescaleValueAxis" ref="a2ba0e1df416486d7e74299ef8cf68bba" args="(bool onlyEnlarge, bool includeErrorBars) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a2ba0e1df416486d7e74299ef8cf68bba">QCPGraph::rescaleValueAxis</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrorBars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to define whether error bars (of kind <a class="el" href="classQCPGraph.html#ad23b514404bd2cb3216f57c90904d6afa147022ccdc49f6bd48f904cb4f61872e">QCPGraph::etValue</a>) are taken into consideration when determining the new axis range. </p>

</div>
</div>
<a class="anchor" id="a659218cc62c2a7786213d9dd429c1c8d"></a><!-- doxytag: member="QCPGraph::draw" ref="a659218cc62c2a7786213d9dd429c1c8d" args="(QCPPainter *painter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a659218cc62c2a7786213d9dd429c1c8d">QCPGraph::draw</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td><code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws this plottable with the provided <em>painter</em>. Called by <a class="el" href="classQCustomPlot.html#ad7a7d878bf050f101a43008e7d8fdb52">QCustomPlot::draw</a> on all its visible plottables.</p>
<p>The cliprect of the provided painter is set to the axis rect of the key/value axis of this plottable (what <a class="el" href="classQCPAbstractPlottable.html#ac01960b0827913922f5364d559c124ed">clipRect</a> returns), before this function is called. </p>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#aae10c24c7ed9d9364f0a5a4d9a5e5aec">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="a9a1a3d937a35368c421657860aa5a173"></a><!-- doxytag: member="QCPGraph::drawLegendIcon" ref="a9a1a3d937a35368c421657860aa5a173" args="(QCPPainter *painter, const QRect &amp;rect) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a9a1a3d937a35368c421657860aa5a173">QCPGraph::drawLegendIcon</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QRect &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by <a class="el" href="classQCPLegend.html#a4462151bf875ca85fa3815457c683fdc">QCPLegend::draw</a> (via <a class="el" href="classQCPPlottableLegendItem.html#ad5f15d26b1c7e2532455528a4c3c578b">QCPPlottableLegendItem::draw</a>) to create a graphical representation of this plottable inside <em>rect</em>, next to the plottable name. </p>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#ab28af4bd3965813be4223d8092aed38b">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="af66183533a29520be3e74489ad1449cc"></a><!-- doxytag: member="QCPGraph::getPlotData" ref="af66183533a29520be3e74489ad1449cc" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#af66183533a29520be3e74489ad1449cc">QCPGraph::getPlotData</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function branches out to the line style specific "get(...)PlotData" functions, according to the line style of the graph. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lineData</td><td>will be filled with raw points that will be drawn with the according draw functions, e.g. <a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a> and <a class="el" href="classQCPGraph.html#abc01180629621f1e47e94559227d3d8c">drawImpulsePlot</a>. These aren't necessarily the original data points, since for step plots for example, additional points are needed for drawing lines that make up steps. If the line style of the graph is <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</a>, the <em>lineData</em> vector will be left untouched. </td></tr>
    <tr><td class="paramname">pointData</td><td>will be filled with the original data points so <a class="el" href="classQCPGraph.html#af1872a60bed7acb3f3b17bfae3f4764c">drawScatterPlot</a> can draw the scatter symbols accordingly. If no scatters need to be drawn, i.e. scatter style is <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>, pass 0 as <em>pointData</em>, and this step will be skipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a0899c4d6357aee19a3abff5897c3c8c5">getScatterPlotData</a>, <a class="el" href="classQCPGraph.html#ac76804eb33446181f3e4f708b7639a75">getLinePlotData</a>, <a class="el" href="classQCPGraph.html#a6b7c14e04deed69b70d552dbe70c4d28">getStepLeftPlotData</a>, <a class="el" href="classQCPGraph.html#ab2ad46716889c73ab977cf9280de0788">getStepRightPlotData</a>, <a class="el" href="classQCPGraph.html#ac79dc75dd98db9948d9656447b463af5">getStepCenterPlotData</a>, <a class="el" href="classQCPGraph.html#a0ff6e856387cc079b28592ead2a81f6c">getImpulsePlotData</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0899c4d6357aee19a3abff5897c3c8c5"></a><!-- doxytag: member="QCPGraph::getScatterPlotData" ref="a0899c4d6357aee19a3abff5897c3c8c5" args="(QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a0899c4d6357aee19a3abff5897c3c8c5">QCPGraph::getScatterPlotData</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If line style is <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</a> and scatter style is not <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>, this function serves at providing the visible data points in <em>pointData</em>, so the <a class="el" href="classQCPGraph.html#af1872a60bed7acb3f3b17bfae3f4764c">drawScatterPlot</a> function can draw the scatter points accordingly.</p>
<p>If line style is not <a class="el" href="classQCPGraph.html#ad60175cd9b5cac937c5ee685c32c0859aea9591b933733cc7b20786b71e60fa04">lsNone</a>, this function is not called and the data for the scatter points are (if needed) calculated inside the corresponding other "get(...)PlotData" functions. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#af1872a60bed7acb3f3b17bfae3f4764c">drawScatterPlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac76804eb33446181f3e4f708b7639a75"></a><!-- doxytag: member="QCPGraph::getLinePlotData" ref="ac76804eb33446181f3e4f708b7639a75" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ac76804eb33446181f3e4f708b7639a75">QCPGraph::getLinePlotData</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for a normal linearly connected plot in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b7c14e04deed69b70d552dbe70c4d28"></a><!-- doxytag: member="QCPGraph::getStepLeftPlotData" ref="a6b7c14e04deed69b70d552dbe70c4d28" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a6b7c14e04deed69b70d552dbe70c4d28">QCPGraph::getStepLeftPlotData</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for a step plot with left oriented steps in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab2ad46716889c73ab977cf9280de0788"></a><!-- doxytag: member="QCPGraph::getStepRightPlotData" ref="ab2ad46716889c73ab977cf9280de0788" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ab2ad46716889c73ab977cf9280de0788">QCPGraph::getStepRightPlotData</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for a step plot with right oriented steps in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac79dc75dd98db9948d9656447b463af5"></a><!-- doxytag: member="QCPGraph::getStepCenterPlotData" ref="ac79dc75dd98db9948d9656447b463af5" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ac79dc75dd98db9948d9656447b463af5">QCPGraph::getStepCenterPlotData</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for a step plot with centered steps in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ff6e856387cc079b28592ead2a81f6c"></a><!-- doxytag: member="QCPGraph::getImpulsePlotData" ref="a0ff6e856387cc079b28592ead2a81f6c" args="(QVector&lt; QPointF &gt; *lineData, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a0ff6e856387cc079b28592ead2a81f6c">QCPGraph::getImpulsePlotData</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Places the raw data points needed for an impulse plot in <em>lineData</em>.</p>
<p>As for all plot data retrieval functions, <em>pointData</em> just contains all unaltered data (scatter) points that are visible, for drawing scatter points, if necessary. If drawing scatter points is disabled (i.e. scatter style <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>), pass 0 as <em>pointData</em>, and the function will skip filling the vector. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#abc01180629621f1e47e94559227d3d8c">drawImpulsePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad6d07926e6d6b7cfa70258780d47b7a0"></a><!-- doxytag: member="QCPGraph::drawFill" ref="ad6d07926e6d6b7cfa70258780d47b7a0" args="(QCPPainter *painter, QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ad6d07926e6d6b7cfa70258780d47b7a0">QCPGraph::drawFill</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws the fill of the graph with the specified brush. If the fill is a normal "base" fill, i.e. under the graph toward the zero-value-line, only the <em>lineData</em> is required (and two extra points at the zero-value-line, which are added by <a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a> and removed by <a class="el" href="classQCPGraph.html#ad31b49a90e91e538fd9caf011c913a68">removeFillBasePoints</a> after the fill drawing is done).</p>
<p>If the fill is a channel fill between this graph and another graph (mChannelFillGraph), the more complex polygon is calculated with the <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a> function. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af1872a60bed7acb3f3b17bfae3f4764c"></a><!-- doxytag: member="QCPGraph::drawScatterPlot" ref="af1872a60bed7acb3f3b17bfae3f4764c" args="(QCPPainter *painter, QVector&lt; QCPData &gt; *pointData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#af1872a60bed7acb3f3b17bfae3f4764c">QCPGraph::drawScatterPlot</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; <a class="el" href="classQCPData.html">QCPData</a> &gt; *&#160;</td>
          <td class="paramname"><em>pointData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws scatter symbols at every data point passed in <em>pointData</em>. scatter symbols are independent of the line style and are always drawn if scatter style is not <a class="el" href="namespaceQCP.html#af66d0711d42fe78d96c28abadc67f26fa3ee9f603bc4623e9b98011e8829aad1d">QCP::ssNone</a>. Hence, the <em>pointData</em> vector is outputted by all "get(...)PlotData" functions, together with the (line style dependent) line data. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a>, <a class="el" href="classQCPGraph.html#abc01180629621f1e47e94559227d3d8c">drawImpulsePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="acebc22c3385829b19a87e6281fe6ade2"></a><!-- doxytag: member="QCPGraph::drawLinePlot" ref="acebc22c3385829b19a87e6281fe6ade2" args="(QCPPainter *painter, QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">QCPGraph::drawLinePlot</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws line graphs from the provided data. It connects all points in <em>lineData</em>, which was created by one of the "get(...)PlotData" functions for line styles that require simple line connections between the point vector they create. These are for example <a class="el" href="classQCPGraph.html#ac76804eb33446181f3e4f708b7639a75">getLinePlotData</a>, <a class="el" href="classQCPGraph.html#a6b7c14e04deed69b70d552dbe70c4d28">getStepLeftPlotData</a>, <a class="el" href="classQCPGraph.html#ab2ad46716889c73ab977cf9280de0788">getStepRightPlotData</a> and <a class="el" href="classQCPGraph.html#ac79dc75dd98db9948d9656447b463af5">getStepCenterPlotData</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#af1872a60bed7acb3f3b17bfae3f4764c">drawScatterPlot</a>, <a class="el" href="classQCPGraph.html#abc01180629621f1e47e94559227d3d8c">drawImpulsePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abc01180629621f1e47e94559227d3d8c"></a><!-- doxytag: member="QCPGraph::drawImpulsePlot" ref="abc01180629621f1e47e94559227d3d8c" args="(QCPPainter *painter, QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#abc01180629621f1e47e94559227d3d8c">QCPGraph::drawImpulsePlot</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Draws impulses graphs from the provided data, i.e. it connects all line pairs in <em>lineData</em>, which was created by <a class="el" href="classQCPGraph.html#a0ff6e856387cc079b28592ead2a81f6c">getImpulsePlotData</a>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#af1872a60bed7acb3f3b17bfae3f4764c">drawScatterPlot</a>, <a class="el" href="classQCPGraph.html#acebc22c3385829b19a87e6281fe6ade2">drawLinePlot</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4df6807066ce877705e999773e7ffbc4"></a><!-- doxytag: member="QCPGraph::drawError" ref="a4df6807066ce877705e999773e7ffbc4" args="(QCPPainter *painter, double x, double y, const QCPData &amp;data) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a4df6807066ce877705e999773e7ffbc4">QCPGraph::drawError</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQCPData.html">QCPData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by the scatter drawing function (<a class="el" href="classQCPGraph.html#af1872a60bed7acb3f3b17bfae3f4764c">drawScatterPlot</a>) to draw the error bars on one data point. <em>x</em> and <em>y</em> pixel positions of the data point are passed since they are already known in pixel coordinates in the drawing function, so we save some extra coordToPixel transforms here. <em>data</em> is therefore only used for the errors, not key and value. </p>

</div>
</div>
<a class="anchor" id="a8963c90087cf53b889b29dd59aa41aad"></a><!-- doxytag: member="QCPGraph::getVisibleDataBounds" ref="a8963c90087cf53b889b29dd59aa41aad" args="(QCPDataMap::const_iterator &amp;lower, QCPDataMap::const_iterator &amp;upper, int &amp;count) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a8963c90087cf53b889b29dd59aa41aad">QCPGraph::getVisibleDataBounds</a> </td>
          <td>(</td>
          <td class="paramtype">QCPDataMap::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">QCPDataMap::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>upper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by the specific plot data generating functions "get(...)PlotData" to determine which data range is visible, so only that needs to be processed.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">lower</td><td>returns an iterator to the lowest data point that needs to be taken into account when plotting. Note that in order to get a clean plot all the way to the edge of the axes, <em>lower</em> may still be outside the visible range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">upper</td><td>returns an iterator to the highest data point. Same as before, <em>upper</em> may also lie outside of the visible range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">count</td><td>number of data points that need plotting, i.e. points between <em>lower</em> and <em>upper</em>, including them. This is useful for allocating the array of QPointFs in the specific drawing functions. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5fa7884620d7c54b81dfbd255d97b636"></a><!-- doxytag: member="QCPGraph::addFillBasePoints" ref="a5fa7884620d7c54b81dfbd255d97b636" args="(QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">QCPGraph::addFillBasePoints</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The line data vector generated by e.g. getLinePlotData contains only the line that connects the data points. If the graph needs to be filled, two additional points need to be added at the value-zero-line in the lower and upper key positions, the graph reaches. This function calculates these points and adds them to the end of <em>lineData</em>. Since the fill is typically drawn before the line stroke, these added points need to be removed again after the fill is done, with the removeFillBasePoints function.</p>
<p>The expanding of <em>lineData</em> by two points will not cause unnecessary memory reallocations, because the data vector generation functions (getLinePlotData etc.) reserve two extra points when they allocate memory for <em>lineData</em>. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#ad31b49a90e91e538fd9caf011c913a68">removeFillBasePoints</a>, <a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">lowerFillBasePoint</a>, <a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">upperFillBasePoint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad31b49a90e91e538fd9caf011c913a68"></a><!-- doxytag: member="QCPGraph::removeFillBasePoints" ref="ad31b49a90e91e538fd9caf011c913a68" args="(QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPGraph.html#ad31b49a90e91e538fd9caf011c913a68">QCPGraph::removeFillBasePoints</a> </td>
          <td>(</td>
          <td class="paramtype">QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>removes the two points from <em>lineData</em> that were added by addFillBasePoints. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a>, <a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">lowerFillBasePoint</a>, <a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">upperFillBasePoint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a41f982e8ceaefe6a53eb7432f26d64b6"></a><!-- doxytag: member="QCPGraph::lowerFillBasePoint" ref="a41f982e8ceaefe6a53eb7432f26d64b6" args="(double lowerKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QPointF <a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">QCPGraph::lowerFillBasePoint</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lowerKey</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by addFillBasePoints to conveniently assign the point which closes the fill polygon on the lower side of the zero-value-line parallel to the key axis. The logarithmic axis scale case is a bit special, since the zero-value-line in pixel coordinates is in positive or negative infinity. So this case is handled separately by just closing the fill polygon on the axis which lies in the direction towards the zero value.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">lowerKey</td><td>pixel position of the lower key of the point. Depending on whether the key axis is horizontal or vertical, <em>lowerKey</em> will end up as the x or y value of the returned point, respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">upperFillBasePoint</a>, <a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a363d066c179e0f46cc93c12bafb0bfba"></a><!-- doxytag: member="QCPGraph::upperFillBasePoint" ref="a363d066c179e0f46cc93c12bafb0bfba" args="(double upperKey) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QPointF <a class="el" href="classQCPGraph.html#a363d066c179e0f46cc93c12bafb0bfba">QCPGraph::upperFillBasePoint</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upperKey</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by addFillBasePoints to conveniently assign the point which closes the fill polygon on the upper side of the zero-value-line parallel to the key axis. The logarithmic axis scale case is a bit special, since the zero-value-line in pixel coordinates is in positive or negative infinity. So this case is handled separately by just closing the fill polygon on the axis which lies in the direction towards the zero value.</p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">upperKey</td><td>pixel position of the upper key of the point. Depending on whether the key axis is horizontal or vertical, <em>upperKey</em> will end up as the x or y value of the returned point, respectively. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#a41f982e8ceaefe6a53eb7432f26d64b6">lowerFillBasePoint</a>, <a class="el" href="classQCPGraph.html#a5fa7884620d7c54b81dfbd255d97b636">addFillBasePoints</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0374b7268e35cab9802a6be2b5d726d7"></a><!-- doxytag: member="QCPGraph::getChannelFillPolygon" ref="a0374b7268e35cab9802a6be2b5d726d7" args="(const QVector&lt; QPointF &gt; *lineData) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QPolygonF <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">QCPGraph::getChannelFillPolygon</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>lineData</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generates the polygon needed for drawing channel fills between this graph (data passed via <em>lineData</em>) and the graph specified by mChannelFillGraph (data generated by calling its <a class="el" href="classQCPGraph.html#af66183533a29520be3e74489ad1449cc">getPlotData</a> function). May return an empty polygon if the key ranges have no overlap or fill target graph and this graph don't have same orientation (i.e. both key axes horizontal or both key axes vertical). For increased performance (due to implicit sharing), keep the returned QPolygonF const. </p>

</div>
</div>
<a class="anchor" id="a6f4e9461d5925be9228fc4760249a04f"></a><!-- doxytag: member="QCPGraph::findIndexBelowX" ref="a6f4e9461d5925be9228fc4760249a04f" args="(const QVector&lt; QPointF &gt; *data, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classQCPGraph.html#a6f4e9461d5925be9228fc4760249a04f">QCPGraph::findIndexBelowX</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the greatest index of <em>data</em>, whose points x value is just below <em>x</em>. Assumes x values in <em>data</em> points are ordered ascending, as is the case when plotting with horizontal key axis. Used to calculate the channel fill polygon, see <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a>. </p>

</div>
</div>
<a class="anchor" id="abab2a75b5e63630432bdd1f3b57f07fa"></a><!-- doxytag: member="QCPGraph::findIndexAboveX" ref="abab2a75b5e63630432bdd1f3b57f07fa" args="(const QVector&lt; QPointF &gt; *data, double x) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classQCPGraph.html#abab2a75b5e63630432bdd1f3b57f07fa">QCPGraph::findIndexAboveX</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the smallest index of <em>data</em>, whose points x value is just above <em>x</em>. Assumes x values in <em>data</em> points are ordered ascending, as is the case when plotting with horizontal key axis. Used to calculate the channel fill polygon, see <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a>. </p>

</div>
</div>
<a class="anchor" id="a6c4d556de3d1e02f548401001f72c6ff"></a><!-- doxytag: member="QCPGraph::findIndexBelowY" ref="a6c4d556de3d1e02f548401001f72c6ff" args="(const QVector&lt; QPointF &gt; *data, double y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classQCPGraph.html#a6c4d556de3d1e02f548401001f72c6ff">QCPGraph::findIndexBelowY</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the greatest index of <em>data</em>, whose points y value is just below <em>y</em>. Assumes y values in <em>data</em> points are ordered descending, as is the case when plotting with vertical key axis (since keys are ordered ascending). Used to calculate the channel fill polygon, see <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a>. </p>

</div>
</div>
<a class="anchor" id="adf50243f1df203883a2187089734bfcb"></a><!-- doxytag: member="QCPGraph::findIndexAboveY" ref="adf50243f1df203883a2187089734bfcb" args="(const QVector&lt; QPointF &gt; *data, double y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classQCPGraph.html#adf50243f1df203883a2187089734bfcb">QCPGraph::findIndexAboveY</a> </td>
          <td>(</td>
          <td class="paramtype">const QVector&lt; QPointF &gt; *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the smallest index of <em>data</em>, whose points y value is just above <em>y</em>. Assumes y values in <em>data</em> points are ordered descending, as is the case when plotting with vertical key axis. Used to calculate the channel fill polygon, see <a class="el" href="classQCPGraph.html#a0374b7268e35cab9802a6be2b5d726d7">getChannelFillPolygon</a>. </p>

</div>
</div>
<a class="anchor" id="af93762a12a481a7edb4b3dd9e330dff1"></a><!-- doxytag: member="QCPGraph::pointDistance" ref="af93762a12a481a7edb4b3dd9e330dff1" args="(const QPointF &amp;pixelPoint) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classQCPGraph.html#af93762a12a481a7edb4b3dd9e330dff1">QCPGraph::pointDistance</a> </td>
          <td>(</td>
          <td class="paramtype">const QPointF &amp;&#160;</td>
          <td class="paramname"><em>pixelPoint</em></td><td>)</td>
          <td> const<code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Calculates the (minimum) distance (in pixels) the graph's representation has from the given <em>pixelPoint</em> in pixels. This is used to determine whether the graph was clicked or not, e.g. in <a class="el" href="classQCPGraph.html#a9a95048dc6daf83e45efbf6d2cdc92d7">selectTest</a>. </p>

</div>
</div>
<a class="anchor" id="ab39c7e8c94b64804a8dc9c19bc7d4683"></a><!-- doxytag: member="QCPGraph::getKeyRange" ref="ab39c7e8c94b64804a8dc9c19bc7d4683" args="(bool &amp;validRange, SignDomain inSignDomain=sdBoth) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPRange.html">QCPRange</a> <a class="el" href="classQCPGraph.html#ab39c7e8c94b64804a8dc9c19bc7d4683">QCPGraph::getKeyRange</a> </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a>&#160;</td>
          <td class="paramname"><em>inSignDomain</em> = <code><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60">sdBoth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by rescaleAxes functions to get the full data key bounds. For logarithmic plots, one can set <em>inSignDomain</em> to either <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63">sdNegative</a> or <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a02951859f243a4d24e779cfbb5471030">sdPositive</a> in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set <em>inSignDomain</em> to <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63">sdNegative</a> and all positive points will be ignored for range calculation. For no restriction, just set <em>inSignDomain</em> to <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60">sdBoth</a> (default). <em>validRange</em> is an output parameter that indicates whether a proper range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa35b75b9032800d783df749c8a004ee9">rescaleAxes</a>, <a class="el" href="classQCPGraph.html#a9fc0c1288455fa5bb64b603d6b01de6c">getValueRange</a> </dd></dl>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#a7aa24ed0b3c39bd99338c7b9f145a71b">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="a9fc0c1288455fa5bb64b603d6b01de6c"></a><!-- doxytag: member="QCPGraph::getValueRange" ref="a9fc0c1288455fa5bb64b603d6b01de6c" args="(bool &amp;validRange, SignDomain inSignDomain=sdBoth) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPRange.html">QCPRange</a> <a class="el" href="classQCPGraph.html#a9fc0c1288455fa5bb64b603d6b01de6c">QCPGraph::getValueRange</a> </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a>&#160;</td>
          <td class="paramname"><em>inSignDomain</em> = <code><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60">sdBoth</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>called by rescaleAxes functions to get the full data value bounds. For logarithmic plots, one can set <em>inSignDomain</em> to either <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63">sdNegative</a> or <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a02951859f243a4d24e779cfbb5471030">sdPositive</a> in order to restrict the returned range to that sign domain. E.g. when only negative range is wanted, set <em>inSignDomain</em> to <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a0fc9a70796ef60ad18ddd18056e6dc63">sdNegative</a> and all positive points will be ignored for range calculation. For no restriction, just set <em>inSignDomain</em> to <a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8a082b98cfb91a7363a3b5cd17b0c1cd60">sdBoth</a> (default). <em>validRange</em> is an output parameter that indicates whether a proper range could be found or not. If this is false, you shouldn't use the returned range (e.g. no points in data).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPGraph.html#aa35b75b9032800d783df749c8a004ee9">rescaleAxes</a>, <a class="el" href="classQCPGraph.html#ab39c7e8c94b64804a8dc9c19bc7d4683">getKeyRange</a> </dd></dl>

<p>Implements <a class="el" href="classQCPAbstractPlottable.html#aed35cfebe5546feea7af2638dd869d5f">QCPAbstractPlottable</a>.</p>

</div>
</div>
<a class="anchor" id="a3a69fbbaea30050a9cfe335a9a01cbf2"></a><!-- doxytag: member="QCPGraph::getKeyRange" ref="a3a69fbbaea30050a9cfe335a9a01cbf2" args="(bool &amp;validRange, SignDomain inSignDomain, bool includeErrors) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPRange.html">QCPRange</a> <a class="el" href="classQCPGraph.html#ab39c7e8c94b64804a8dc9c19bc7d4683">QCPGraph::getKeyRange</a> </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a>&#160;</td>
          <td class="paramname"><em>inSignDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to specify whether the error bars should be included in the range calculation.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>getKeyRange(bool &amp;validRange, SignDomain inSignDomain) </dd></dl>

</div>
</div>
<a class="anchor" id="acdb1e7bb86fea2764b0adb104185832b"></a><!-- doxytag: member="QCPGraph::getValueRange" ref="acdb1e7bb86fea2764b0adb104185832b" args="(bool &amp;validRange, SignDomain inSignDomain, bool includeErrors) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classQCPRange.html">QCPRange</a> <a class="el" href="classQCPGraph.html#a9fc0c1288455fa5bb64b603d6b01de6c">QCPGraph::getValueRange</a> </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>validRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classQCPAbstractPlottable.html#a661743478a1d3c09d28ec2711d7653d8">SignDomain</a>&#160;</td>
          <td class="paramname"><em>inSignDomain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Allows to specify whether the error bars should be included in the range calculation.</p>
<dl class="see"><dt><b>See also:</b></dt><dd>getValueRange(bool &amp;validRange, SignDomain inSignDomain) </dd></dl>

</div>
</div>
<a class="anchor" id="ab79c7ba76bc7fa89a4b3580e12149f1f"></a><!-- doxytag: member="QCPGraph::setName" ref="ab79c7ba76bc7fa89a4b3580e12149f1f" args="(const QString &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#ab79c7ba76bc7fa89a4b3580e12149f1f">QCPAbstractPlottable::setName</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The name is the textual representation of this plottable as it is displayed in the <a class="el" href="classQCPLegend.html" title="Manages a legend inside a QCustomPlot.">QCPLegend</a> of the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>. It may contain any utf-8 characters, including newlines. </p>

</div>
</div>
<a class="anchor" id="a089d6b5577120239b55c39ed27c39536"></a><!-- doxytag: member="QCPGraph::setAntialiasedFill" ref="a089d6b5577120239b55c39ed27c39536" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a089d6b5577120239b55c39ed27c39536">QCPAbstractPlottable::setAntialiasedFill</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets whether fills of this plottable is drawn antialiased or not.</p>
<p>Note that this setting may be overridden by <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. </p>

</div>
</div>
<a class="anchor" id="a2f03f067ede2ed4da6f7d0e4777a3f02"></a><!-- doxytag: member="QCPGraph::setAntialiasedScatters" ref="a2f03f067ede2ed4da6f7d0e4777a3f02" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a2f03f067ede2ed4da6f7d0e4777a3f02">QCPAbstractPlottable::setAntialiasedScatters</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets whether the scatter symbols of this plottable are drawn antialiased or not.</p>
<p>Note that this setting may be overridden by <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. </p>

</div>
</div>
<a class="anchor" id="a757beb744b96cf1855cca5ab9d3ecf52"></a><!-- doxytag: member="QCPGraph::setAntialiasedErrorBars" ref="a757beb744b96cf1855cca5ab9d3ecf52" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a757beb744b96cf1855cca5ab9d3ecf52">QCPAbstractPlottable::setAntialiasedErrorBars</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets whether the error bars of this plottable are drawn antialiased or not.</p>
<p>Note that this setting may be overridden by <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. </p>

</div>
</div>
<a class="anchor" id="ab74b09ae4c0e7e13142fe4b5bf46cac7"></a><!-- doxytag: member="QCPGraph::setPen" ref="ab74b09ae4c0e7e13142fe4b5bf46cac7" args="(const QPen &amp;pen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">QCPAbstractPlottable::setPen</a> </td>
          <td>(</td>
          <td class="paramtype">const QPen &amp;&#160;</td>
          <td class="paramname"><em>pen</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The pen is used to draw basic lines that make up the plottable representation in the plot.</p>
<p>For example, the <a class="el" href="classQCPGraph.html">QCPGraph</a> subclass draws its graph lines and scatter points with this pen.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6911603cad23ab0469b108224517516f"></a><!-- doxytag: member="QCPGraph::setSelectedPen" ref="a6911603cad23ab0469b108224517516f" args="(const QPen &amp;pen)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a6911603cad23ab0469b108224517516f">QCPAbstractPlottable::setSelectedPen</a> </td>
          <td>(</td>
          <td class="paramtype">const QPen &amp;&#160;</td>
          <td class="paramname"><em>pen</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When the plottable is selected, this pen is used to draw basic lines instead of the normal pen set via <a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#afbd5428c2952f59d952e11ab5cd79176">setSelected</a>, <a class="el" href="classQCPAbstractPlottable.html#a22c69299eb5569e0f6bf084877a37dc4">setSelectable</a>, <a class="el" href="classQCPAbstractPlottable.html#ae8c816874089f7a44001e8618e81a9dc">setSelectedBrush</a>, <a class="el" href="classQCPAbstractPlottable.html#a0fd218d6c4974b6ab05bd2f688818556">selectTest</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7a4b92144dca6453a1f0f210e27edc74"></a><!-- doxytag: member="QCPGraph::setBrush" ref="a7a4b92144dca6453a1f0f210e27edc74" args="(const QBrush &amp;brush)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">QCPAbstractPlottable::setBrush</a> </td>
          <td>(</td>
          <td class="paramtype">const QBrush &amp;&#160;</td>
          <td class="paramname"><em>brush</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The brush is used to draw basic fills of the plottable representation in the plot. The Fill can be a color, gradient or texture, see the usage of QBrush.</p>
<p>For example, the <a class="el" href="classQCPGraph.html">QCPGraph</a> subclass draws the fill under the graph with this brush, when it's not set to Qt::NoBrush.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#ab74b09ae4c0e7e13142fe4b5bf46cac7">setPen</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae8c816874089f7a44001e8618e81a9dc"></a><!-- doxytag: member="QCPGraph::setSelectedBrush" ref="ae8c816874089f7a44001e8618e81a9dc" args="(const QBrush &amp;brush)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#ae8c816874089f7a44001e8618e81a9dc">QCPAbstractPlottable::setSelectedBrush</a> </td>
          <td>(</td>
          <td class="paramtype">const QBrush &amp;&#160;</td>
          <td class="paramname"><em>brush</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When the plottable is selected, this brush is used to draw fills instead of the normal brush set via <a class="el" href="classQCPAbstractPlottable.html#a7a4b92144dca6453a1f0f210e27edc74">setBrush</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#afbd5428c2952f59d952e11ab5cd79176">setSelected</a>, <a class="el" href="classQCPAbstractPlottable.html#a22c69299eb5569e0f6bf084877a37dc4">setSelectable</a>, <a class="el" href="classQCPAbstractPlottable.html#a6911603cad23ab0469b108224517516f">setSelectedPen</a>, <a class="el" href="classQCPAbstractPlottable.html#a0fd218d6c4974b6ab05bd2f688818556">selectTest</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8524fa2994c63c0913ebd9bb2ffa3920"></a><!-- doxytag: member="QCPGraph::setKeyAxis" ref="a8524fa2994c63c0913ebd9bb2ffa3920" args="(QCPAxis *axis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a8524fa2994c63c0913ebd9bb2ffa3920">QCPAbstractPlottable::setKeyAxis</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The key axis of a plottable can be set to any axis of a <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>, as long as it is orthogonal to the plottable's value axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis (QCustomPlot::xAxis) as key axis and the y-axis (QCustomPlot::yAxis) as value axis.</p>
<p>Normally, the key and value axes are set in the constructor of the plottable (or <a class="el" href="classQCustomPlot.html#a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</a> when working with QCPGraphs through the dedicated graph interface).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a71626a07367e241ec62ad2c34baf21cb">setValueAxis</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a71626a07367e241ec62ad2c34baf21cb"></a><!-- doxytag: member="QCPGraph::setValueAxis" ref="a71626a07367e241ec62ad2c34baf21cb" args="(QCPAxis *axis)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a71626a07367e241ec62ad2c34baf21cb">QCPAbstractPlottable::setValueAxis</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPAxis.html">QCPAxis</a> *&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The value axis of a plottable can be set to any axis of a <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>, as long as it is orthogonal to the plottable's key axis. This function performs no checks to make sure this is the case. The typical mathematical choice is to use the x-axis (QCustomPlot::xAxis) as key axis and the y-axis (QCustomPlot::yAxis) as value axis.</p>
<p>Normally, the key and value axes are set in the constructor of the plottable (or <a class="el" href="classQCustomPlot.html#a6fb2873d35a8a8089842d81a70a54167">QCustomPlot::addGraph</a> when working with QCPGraphs through the dedicated graph interface).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a8524fa2994c63c0913ebd9bb2ffa3920">setKeyAxis</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22c69299eb5569e0f6bf084877a37dc4"></a><!-- doxytag: member="QCPGraph::setSelectable" ref="a22c69299eb5569e0f6bf084877a37dc4" args="(bool selectable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a22c69299eb5569e0f6bf084877a37dc4">QCPAbstractPlottable::setSelectable</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selectable</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets whether the user can (de-)select this plottable by clicking on the <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> surface. (When <a class="el" href="classQCustomPlot.html#add9cc886ff5257f64fb4117cf6c135fe">QCustomPlot::setInteractions</a> contains iSelectPlottables.)</p>
<p>However, even when <em>selectable</em> was set to false, it is possible to set the selection manually, by calling <a class="el" href="classQCPAbstractPlottable.html#afbd5428c2952f59d952e11ab5cd79176">setSelected</a> directly.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#afbd5428c2952f59d952e11ab5cd79176">setSelected</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbd5428c2952f59d952e11ab5cd79176"></a><!-- doxytag: member="QCPGraph::setSelected" ref="afbd5428c2952f59d952e11ab5cd79176" args="(bool selected)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#afbd5428c2952f59d952e11ab5cd79176">QCPAbstractPlottable::setSelected</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selected</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets whether this plottable is selected or not. When selected, it uses a different pen and brush to draw its lines and fills, see <a class="el" href="classQCPAbstractPlottable.html#a6911603cad23ab0469b108224517516f">setSelectedPen</a> and <a class="el" href="classQCPAbstractPlottable.html#ae8c816874089f7a44001e8618e81a9dc">setSelectedBrush</a>.</p>
<p>The entire selection mechanism for plottables is handled automatically when <a class="el" href="classQCustomPlot.html#add9cc886ff5257f64fb4117cf6c135fe">QCustomPlot::setInteractions</a> contains iSelectPlottables. You only need to call this function when you wish to change the selection state manually.</p>
<p>This function can change the selection state even when <a class="el" href="classQCPAbstractPlottable.html#a22c69299eb5569e0f6bf084877a37dc4">setSelectable</a> was set to false.</p>
<p>emits the <a class="el" href="classQCPAbstractPlottable.html#a3af66432b1dca93b28e00e78a8c7c1d9">selectionChanged</a> signal when <em>selected</em> is different from the previous selection state.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a0fd218d6c4974b6ab05bd2f688818556">selectTest</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7e8fc3be43c27ccacd70a7bf9d74a5cd"></a><!-- doxytag: member="QCPGraph::rescaleAxes" ref="a7e8fc3be43c27ccacd70a7bf9d74a5cd" args="(bool onlyEnlarge=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a7e8fc3be43c27ccacd70a7bf9d74a5cd">QCPAbstractPlottable::rescaleAxes</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em> = <code>false</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rescales the key and value axes associated with this plottable to contain all displayed data, so the whole plottable is visible. If the scaling of an axis is logarithmic, rescaleAxes will make sure not to rescale to an illegal range i.e. a range containing different signs and/or zero. Instead it will stay in the current sign domain and ignore all parts of the plottable that lie outside of that domain.</p>
<p><em>onlyEnlarge</em> makes sure the ranges are only expanded, never reduced. So it's possible to show multiple plottables in their entirety by multiple calls to rescaleAxes where the first call has <em>onlyEnlarge</em> set to false (the default), and all subsequent set to true. </p>

</div>
</div>
<a class="anchor" id="a1acecfcca3e7fcda00fcbaa3c886386f"></a><!-- doxytag: member="QCPGraph::rescaleKeyAxis" ref="a1acecfcca3e7fcda00fcbaa3c886386f" args="(bool onlyEnlarge=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a1acecfcca3e7fcda00fcbaa3c886386f">QCPAbstractPlottable::rescaleKeyAxis</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em> = <code>false</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rescales the key axis of the plottable so the whole plottable is visible.</p>
<p>See <a class="el" href="classQCPAbstractPlottable.html#a7e8fc3be43c27ccacd70a7bf9d74a5cd">rescaleAxes</a> for detailed behaviour. </p>

</div>
</div>
<a class="anchor" id="abfd0805eb1d955c0111a990246658324"></a><!-- doxytag: member="QCPGraph::rescaleValueAxis" ref="abfd0805eb1d955c0111a990246658324" args="(bool onlyEnlarge=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#abfd0805eb1d955c0111a990246658324">QCPAbstractPlottable::rescaleValueAxis</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>onlyEnlarge</em> = <code>false</code></td><td>)</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Rescales the value axis of the plottable so the whole plottable is visible.</p>
<p>See <a class="el" href="classQCPAbstractPlottable.html#a7e8fc3be43c27ccacd70a7bf9d74a5cd">rescaleAxes</a> for detailed behaviour. </p>

</div>
</div>
<a class="anchor" id="a70f8cabfd808f7d5204b9f18c45c13f5"></a><!-- doxytag: member="QCPGraph::addToLegend" ref="a70f8cabfd808f7d5204b9f18c45c13f5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQCPAbstractPlottable.html#a70f8cabfd808f7d5204b9f18c45c13f5">QCPAbstractPlottable::addToLegend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Adds this plottable to the legend of the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>.</p>
<p>Normally, a <a class="el" href="classQCPPlottableLegendItem.html" title="A legend item representing a plottable with an icon and the plottable name.">QCPPlottableLegendItem</a> is created and inserted into the legend. If the plottable needs a more specialized representation in the plot, this function will take this into account and instead create the specialized subclass of <a class="el" href="classQCPAbstractLegendItem.html" title="The abstract base class for all items in a QCPLegend.">QCPAbstractLegendItem</a>.</p>
<p>Returns true on success, i.e. when a legend item associated with this plottable isn't already in the legend.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#aa1f350e510326d012b9a9c9249736c83">removeFromLegend</a>, <a class="el" href="classQCPLegend.html#a3ab274de52d2951faea45a6d975e6b3f">QCPLegend::addItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa1f350e510326d012b9a9c9249736c83"></a><!-- doxytag: member="QCPGraph::removeFromLegend" ref="aa1f350e510326d012b9a9c9249736c83" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQCPAbstractPlottable.html#aa1f350e510326d012b9a9c9249736c83">QCPAbstractPlottable::removeFromLegend</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Removes the plottable from the legend of the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>. This means the <a class="el" href="classQCPAbstractLegendItem.html" title="The abstract base class for all items in a QCPLegend.">QCPAbstractLegendItem</a> (usually a <a class="el" href="classQCPPlottableLegendItem.html" title="A legend item representing a plottable with an icon and the plottable name.">QCPPlottableLegendItem</a>) that is associated with this plottable is removed.</p>
<p>Returns true on success, i.e. if a legend item associated with this plottable was found and removed from the legend.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a70f8cabfd808f7d5204b9f18c45c13f5">addToLegend</a>, <a class="el" href="classQCPLegend.html#ac91595c3eaa746fe6321d2eb952c63bb">QCPLegend::removeItem</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3af66432b1dca93b28e00e78a8c7c1d9"></a><!-- doxytag: member="QCPGraph::selectionChanged" ref="a3af66432b1dca93b28e00e78a8c7c1d9" args="(bool selected)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a3af66432b1dca93b28e00e78a8c7c1d9">QCPAbstractPlottable::selectionChanged</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>selected</em></td><td>)</td>
          <td><code> [signal, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This signal is emitted when the selection state of this plottable has changed, either by user interaction or by a direct call to <a class="el" href="classQCPAbstractPlottable.html#afbd5428c2952f59d952e11ab5cd79176">setSelected</a>. </p>

</div>
</div>
<a class="anchor" id="ac01960b0827913922f5364d559c124ed"></a><!-- doxytag: member="QCPGraph::clipRect" ref="ac01960b0827913922f5364d559c124ed" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QRect <a class="el" href="classQCPAbstractPlottable.html#ac01960b0827913922f5364d559c124ed">QCPAbstractPlottable::clipRect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the clipping rectangle of this layerable object. By default, this is the viewport of the parent <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a>. Specific subclasses may reimplement this function to provide different clipping rects.</p>
<p>The returned clipping rect is set on the painter before the draw function of the respective object is called. </p>

<p>Reimplemented from <a class="el" href="classQCPLayerable.html#a07a8f746640c3704b09910df297afcba">QCPLayerable</a>.</p>

</div>
</div>
<a class="anchor" id="ade710a776104b14c1c835168ce1bfc5c"></a><!-- doxytag: member="QCPGraph::coordsToPixels" ref="ade710a776104b14c1c835168ce1bfc5c" args="(double key, double value, double &amp;x, double &amp;y) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#ade710a776104b14c1c835168ce1bfc5c">QCPAbstractPlottable::coordsToPixels</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience function for transforming a key/value pair to pixels on the <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> surface, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).</p>
<p><em>key</em> and <em>value</em> are transformed to the coodinates in pixels and are written to <em>x</em> and <em>y</em>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#a10408828446e9e0681c46d65120f382e">pixelsToCoords</a>, <a class="el" href="classQCPAxis.html#a985ae693b842fb0422b4390fe36d299a">QCPAxis::coordToPixel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9fd1c9df8391781f05b0be22fbe91e13"></a><!-- doxytag: member="QCPGraph::coordsToPixels" ref="a9fd1c9df8391781f05b0be22fbe91e13" args="(double key, double value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const QPointF <a class="el" href="classQCPAbstractPlottable.html#ade710a776104b14c1c835168ce1bfc5c">QCPAbstractPlottable::coordsToPixels</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Returns the input as pixel coordinates in a QPointF. </p>

</div>
</div>
<a class="anchor" id="a10408828446e9e0681c46d65120f382e"></a><!-- doxytag: member="QCPGraph::pixelsToCoords" ref="a10408828446e9e0681c46d65120f382e" args="(double x, double y, double &amp;key, double &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a10408828446e9e0681c46d65120f382e">QCPAbstractPlottable::pixelsToCoords</a> </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convenience function for transforming a x/y pixel pair on the <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> surface to plot coordinates, taking the orientations of the axes associated with this plottable into account (e.g. whether key represents x or y).</p>
<p><em>x</em> and <em>y</em> are transformed to the plot coodinates and are written to <em>key</em> and <em>value</em>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPAbstractPlottable.html#ade710a776104b14c1c835168ce1bfc5c">coordsToPixels</a>, <a class="el" href="classQCPAxis.html#a985ae693b842fb0422b4390fe36d299a">QCPAxis::coordToPixel</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3e2c361cfcdfd5d803ada4d333a07e15"></a><!-- doxytag: member="QCPGraph::pixelsToCoords" ref="a3e2c361cfcdfd5d803ada4d333a07e15" args="(const QPointF &amp;pixelPos, double &amp;key, double &amp;value) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a10408828446e9e0681c46d65120f382e">QCPAbstractPlottable::pixelsToCoords</a> </td>
          <td>(</td>
          <td class="paramtype">const QPointF &amp;&#160;</td>
          <td class="paramname"><em>pixelPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Returns the pixel input <em>pixelPos</em> as plot coordinates <em>key</em> and <em>value</em>. </p>

</div>
</div>
<a class="anchor" id="a19276ed2382a3a06464417b8788b1451"></a><!-- doxytag: member="QCPGraph::mainPen" ref="a19276ed2382a3a06464417b8788b1451" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QPen <a class="el" href="classQCPAbstractPlottable.html#a19276ed2382a3a06464417b8788b1451">QCPAbstractPlottable::mainPen</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the pen that should be used for drawing lines of the plottable. Returns mPen when the graph is not selected and mSelectedPen when it is. </p>

</div>
</div>
<a class="anchor" id="ae74c123832da180c17e22203e748d9b7"></a><!-- doxytag: member="QCPGraph::mainBrush" ref="ae74c123832da180c17e22203e748d9b7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QBrush <a class="el" href="classQCPAbstractPlottable.html#ae74c123832da180c17e22203e748d9b7">QCPAbstractPlottable::mainBrush</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the brush that should be used for drawing fills of the plottable. Returns mBrush when the graph is not selected and mSelectedBrush when it is. </p>

</div>
</div>
<a class="anchor" id="a76e9d6cc7972dc1528f526d163766aca"></a><!-- doxytag: member="QCPGraph::applyDefaultAntialiasingHint" ref="a76e9d6cc7972dc1528f526d163766aca" args="(QCPPainter *painter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a76e9d6cc7972dc1528f526d163766aca">QCPAbstractPlottable::applyDefaultAntialiasingHint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td> const<code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function to easily set the QPainter::Antialiased hint on the provided <em>painter</em> before drawing plottable lines.</p>
<p>This is the antialiasing state the painter passed to the <a class="el" href="classQCPAbstractPlottable.html#aae10c24c7ed9d9364f0a5a4d9a5e5aec">draw</a> method is in by default.</p>
<p>This function takes into account the local setting of the antialiasing flag as well as the overrides set e.g. with <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">setAntialiased</a>, <a class="el" href="classQCPAbstractPlottable.html#ac08a480155895e674dbfe5a5670e0ff3">applyFillAntialiasingHint</a>, <a class="el" href="classQCPAbstractPlottable.html#a753272ee225a62827e90c3e1e78de4b1">applyScattersAntialiasingHint</a>, <a class="el" href="classQCPAbstractPlottable.html#af687bfe6160255960558eb71f1f81e73">applyErrorBarsAntialiasingHint</a> </dd></dl>

<p>Implements <a class="el" href="classQCPLayerable.html#afdf83ddc6a265cbf4c89fe99d3d93473">QCPLayerable</a>.</p>

</div>
</div>
<a class="anchor" id="ac08a480155895e674dbfe5a5670e0ff3"></a><!-- doxytag: member="QCPGraph::applyFillAntialiasingHint" ref="ac08a480155895e674dbfe5a5670e0ff3" args="(QCPPainter *painter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#ac08a480155895e674dbfe5a5670e0ff3">QCPAbstractPlottable::applyFillAntialiasingHint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function to easily set the QPainter::Antialiased hint on the provided <em>painter</em> before drawing plottable fills.</p>
<p>This function takes into account the local setting of the fill antialiasing flag as well as the overrides set e.g. with <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">setAntialiased</a>, <a class="el" href="classQCPAbstractPlottable.html#a76e9d6cc7972dc1528f526d163766aca">applyDefaultAntialiasingHint</a>, <a class="el" href="classQCPAbstractPlottable.html#a753272ee225a62827e90c3e1e78de4b1">applyScattersAntialiasingHint</a>, <a class="el" href="classQCPAbstractPlottable.html#af687bfe6160255960558eb71f1f81e73">applyErrorBarsAntialiasingHint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a753272ee225a62827e90c3e1e78de4b1"></a><!-- doxytag: member="QCPGraph::applyScattersAntialiasingHint" ref="a753272ee225a62827e90c3e1e78de4b1" args="(QCPPainter *painter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#a753272ee225a62827e90c3e1e78de4b1">QCPAbstractPlottable::applyScattersAntialiasingHint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function to easily set the QPainter::Antialiased hint on the provided <em>painter</em> before drawing plottable scatter points.</p>
<p>This function takes into account the local setting of the scatters antialiasing flag as well as the overrides set e.g. with <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">setAntialiased</a>, <a class="el" href="classQCPAbstractPlottable.html#ac08a480155895e674dbfe5a5670e0ff3">applyFillAntialiasingHint</a>, <a class="el" href="classQCPAbstractPlottable.html#a76e9d6cc7972dc1528f526d163766aca">applyDefaultAntialiasingHint</a>, <a class="el" href="classQCPAbstractPlottable.html#af687bfe6160255960558eb71f1f81e73">applyErrorBarsAntialiasingHint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af687bfe6160255960558eb71f1f81e73"></a><!-- doxytag: member="QCPGraph::applyErrorBarsAntialiasingHint" ref="af687bfe6160255960558eb71f1f81e73" args="(QCPPainter *painter) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPAbstractPlottable.html#af687bfe6160255960558eb71f1f81e73">QCPAbstractPlottable::applyErrorBarsAntialiasingHint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em></td><td>)</td>
          <td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>A convenience function to easily set the QPainter::Antialiased hint on the provided <em>painter</em> before drawing plottable error bars.</p>
<p>This function takes into account the local setting of the error bars antialiasing flag as well as the overrides set e.g. with <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">setAntialiased</a>, <a class="el" href="classQCPAbstractPlottable.html#ac08a480155895e674dbfe5a5670e0ff3">applyFillAntialiasingHint</a>, <a class="el" href="classQCPAbstractPlottable.html#a753272ee225a62827e90c3e1e78de4b1">applyScattersAntialiasingHint</a>, <a class="el" href="classQCPAbstractPlottable.html#a76e9d6cc7972dc1528f526d163766aca">applyDefaultAntialiasingHint</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5ea1cab44ca912dcdc96ed81ec5bed5d"></a><!-- doxytag: member="QCPGraph::distSqrToLine" ref="a5ea1cab44ca912dcdc96ed81ec5bed5d" args="(const QPointF &amp;start, const QPointF &amp;end, const QPointF &amp;point) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classQCPAbstractPlottable.html#a5ea1cab44ca912dcdc96ed81ec5bed5d">QCPAbstractPlottable::distSqrToLine</a> </td>
          <td>(</td>
          <td class="paramtype">const QPointF &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QPointF &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QPointF &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Finds the shortest squared distance of <em>point</em> to the line segment defined by <em>start</em> and <em>end</em>.</p>
<p>This function may be used to help with the implementation of the <a class="el" href="classQCPAbstractPlottable.html#a0fd218d6c4974b6ab05bd2f688818556">selectTest</a> function for specific plottables.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is identical to <a class="el" href="classQCPAbstractItem.html#acdca343717d625b8abb3c3e38c0ed39d">QCPAbstractItem::distSqrToLine</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bed99ddc396b48ce3ebfdc0418744f8"></a><!-- doxytag: member="QCPGraph::setVisible" ref="a3bed99ddc396b48ce3ebfdc0418744f8" args="(bool on)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPLayerable.html#a3bed99ddc396b48ce3ebfdc0418744f8">QCPLayerable::setVisible</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the visibility of this layerable object. If an object is not visible, it will not be drawn on the <a class="el" href="classQCustomPlot.html" title="The central class of the library, the QWidget which displays the plot and interacts with the user...">QCustomPlot</a> surface, and user interaction with it (e.g. click/selection) is not possible. </p>

</div>
</div>
<a class="anchor" id="ab0d0da6d2de45a118886d2c8e16d5a54"></a><!-- doxytag: member="QCPGraph::setLayer" ref="ab0d0da6d2de45a118886d2c8e16d5a54" args="(QCPLayer *layer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQCPLayerable.html#ab0d0da6d2de45a118886d2c8e16d5a54">QCPLayerable::setLayer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPLayer.html">QCPLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the <em>layer</em> of this layerable object. The object will be placed on top of the other objects already on <em>layer</em>.</p>
<p>Returns true on success, i.e. if <em>layer</em> is a valid layer. </p>

</div>
</div>
<a class="anchor" id="ab25a0e7b897993b44447caee0f142083"></a><!-- doxytag: member="QCPGraph::setLayer" ref="ab25a0e7b897993b44447caee0f142083" args="(const QString &amp;layerName)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQCPLayerable.html#ab0d0da6d2de45a118886d2c8e16d5a54">QCPLayerable::setLayer</a> </td>
          <td>(</td>
          <td class="paramtype">const QString &amp;&#160;</td>
          <td class="paramname"><em>layerName</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is an overloaded function.</p>
<p>Sets the layer of this layerable object by name</p>
<p>Returns true on success, i.e. if <em>layerName</em> is a valid layer name. </p>

</div>
</div>
<a class="anchor" id="a4fd43e89be4a553ead41652565ff0581"></a><!-- doxytag: member="QCPGraph::setAntialiased" ref="a4fd43e89be4a553ead41652565ff0581" args="(bool enabled)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPLayerable.html#a4fd43e89be4a553ead41652565ff0581">QCPLayerable::setAntialiased</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets whether this object will be drawn antialiased or not.</p>
<p>Note that antialiasing settings may be overridden by <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. </p>

</div>
</div>
<a class="anchor" id="af94484cfb7cbbddb7de522e9be71d9a4"></a><!-- doxytag: member="QCPGraph::moveToLayer" ref="af94484cfb7cbbddb7de522e9be71d9a4" args="(QCPLayer *layer, bool prepend)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classQCPLayerable.html#af94484cfb7cbbddb7de522e9be71d9a4">QCPLayerable::moveToLayer</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPLayer.html">QCPLayer</a> *&#160;</td>
          <td class="paramname"><em>layer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prepend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Moves this layerable object to <em>layer</em>. If <em>prepend</em> is true, this object will be prepended to the new layer's list, i.e. it will be drawn below the objects already on the layer. If it is false, the object will be appended.</p>
<p>Returns true on success, i.e. if <em>layer</em> is a valid layer. </p>

</div>
</div>
<a class="anchor" id="a62bd552d1a45aa9accb24b310542279e"></a><!-- doxytag: member="QCPGraph::applyAntialiasingHint" ref="a62bd552d1a45aa9accb24b310542279e" args="(QCPPainter *painter, bool localAntialiased, QCP::AntialiasedElement overrideElement) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classQCPLayerable.html#a62bd552d1a45aa9accb24b310542279e">QCPLayerable::applyAntialiasingHint</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classQCPPainter.html">QCPPainter</a> *&#160;</td>
          <td class="paramname"><em>painter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>localAntialiased</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceQCP.html#ae55dbe315d41fe80f29ba88100843a0c">QCP::AntialiasedElement</a>&#160;</td>
          <td class="paramname"><em>overrideElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Sets the QPainter::Antialiasing render hint on the provided <em>painter</em>, depending on the <em>localAntialiased</em> value as well as the overrides <a class="el" href="classQCustomPlot.html#af6f91e5eab1be85f67c556e98c3745e8">QCustomPlot::setAntialiasedElements</a> and <a class="el" href="classQCustomPlot.html#ae10d685b5eabea2999fb8775ca173c24">QCustomPlot::setNotAntialiasedElements</a>. Which override enum this function takes into account is controlled via <em>overrideElement</em>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="qcustomplot_8h_source.html">qcustomplot.h</a></li>
<li>qcustomplot.cpp</li>
</ul>
</div><!-- contents -->
<div class="footer" />Generated with <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.7.6.1</div>
</body>
</html>
